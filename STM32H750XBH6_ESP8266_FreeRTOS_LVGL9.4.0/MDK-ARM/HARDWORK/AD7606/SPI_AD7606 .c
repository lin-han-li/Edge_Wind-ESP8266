#include "stm32h7xx_hal.h"
#include <stdio.h>
#include "SPI_AD7606.h"
#include "Delay.h"

volatile uint32_t g_ad7606_frames = 0;
volatile uint32_t g_ad7606_miss = 0;

/*
*********************************************************************************************************
* 函 数 名: SPI_Delay
* 功能说明: 时序延迟，用于软件模拟SPI时的时钟延时
* 形    参: 无
* 返 回 值: 无
* 说    明: 通过空循环实现微秒级或纳秒级延时，控制SCK时钟频率
*********************************************************************************************************
*/
void SPI_Delay(void)
{
#if 1
	uint32_t i;

	/*
	   延迟15个循环。
	   参考数据：F407 (168MHz主频） GPIO模拟，实测 SCK 周期 = 480ns (大约2MHz SPI速率)
	   H7系列主频更高，此延时对应的频率会更高，需确保不超过AD7606的时序限制
	*/
	for (i = 0; i < 15; i++)
		;
#else
	/*
	   不添加延迟语句， F407 (168MHz主频） GPIO模拟，实测 SCK 周期 = 200ns (大约5M)
	*/
#endif
}

/*
*********************************************************************************************************
* 函 数 名: AD7606_Init
* 功能说明: AD7606 芯片初始化流程
* 形    参: 无
* 返 回 值: 无
*********************************************************************************************************
*/
void AD7606_Init()
{
	g_ad7606_frames = 0;
	g_ad7606_miss = 0;

	/* 1. 配置STM32的GPIO引脚模式（推挽输出、浮空输入等） */
	// AD7606_ConfigGPIO(); // 如果此函数在其他地方定义，需取消注释

	/* 2. 初始化控制引脚的默认电平 */
	AD7606_CONVEST_A_H; // 转换开始信号A置高
	AD7606_CONVEST_B_H; // 转换开始信号B置高
	HAL_Delay(1);		// 等待上电稳定（RTOS运行时为osDelay）

	// STby_Set;        // 退出待机模式（如果使用了STBY引脚）
	AD7606_SCLK_H;     // SPI时钟线默认拉高（空闲态为高，CPOL=1）
	AD7606_CS_H;      // 片选信号拉高，取消选中

	/* 3. 设置过采样模式 (Oversampling) */
	/* 默认先全部拉低 */
	AD7606_OS2_L;
	AD7606_OS1_L;
	AD7606_OS0_L;
	AD7606_SetOS(AD7606_OS_MODE); //

	/* 4. 执行硬件复位 */
	AD7606_Reset(); // 发送复位脉冲，复位内部寄存器
	HAL_Delay(1);	// 复位后等待芯片就绪（RTOS运行时为osDelay）

	/* 5. 确保CONVST引脚状态正确，准备开始转换 */
	AD7606_CONVEST_A_H;
	AD7606_CONVEST_B_H;

	/* 6. 由外部采样调度触发转换 */
}

/*
*********************************************************************************************************
* 函 数 名: AD7606_SetOS
* 功能说明: 设置过采样模式（数字滤波，硬件求平均值)
* 形    参: _ucMode : 0-6
*
* 【AD7606 过采样模式参数表】
* | _ucMode | 过采样倍数 | 转换时间(t_conv) | 理论最高采样率 |
* |---------|------------|------------------|----------------|
* |    0    |   No OS    |      4 μs        |    200 kSPS    |
* |    1    |     2      |    8.7 μs        |    100 kSPS    |
* |    2    |     4      |   17.5 μs        |     50 kSPS    |
* |    3    |     8      |     35 μs        |     25 kSPS    |
* |    4    |    16      |     70 μs        |   12.5 kSPS    |
* |    5    |    32      |    140 μs        |   6.25 kSPS    | 
* |    6    |    64      |    280 μs        |  3.125 kSPS    |
*
* 返 回 值: 无
* 说    明: 通过控制 OS2, OS1, OS0 三个引脚的高低电平组合来选择模式
*********************************************************************************************************
*/
void AD7606_SetOS(uint8_t _ucMode)
{
	if (_ucMode == 1) // 2倍
	{
		AD7606_OS2_L;
		AD7606_OS1_L;
		AD7606_OS0_H;
	}
	else if (_ucMode == 2) // 4倍
	{
		AD7606_OS2_L;
		AD7606_OS1_H;
		AD7606_OS0_L;
	}
	else if (_ucMode == 3) // 8倍
	{
		AD7606_OS2_L;
		AD7606_OS1_H;
		AD7606_OS0_H;
	}
	else if (_ucMode == 4) // 16倍
	{
		AD7606_OS2_H;
		AD7606_OS1_L;
		AD7606_OS0_L;
	}
	else if (_ucMode == 5) // 32倍
	{
		AD7606_OS2_H;
		AD7606_OS1_L;
		AD7606_OS0_H;
	}
	else if (_ucMode == 6) // 64倍
	{
		AD7606_OS2_H;
		AD7606_OS1_H;
		AD7606_OS0_L;
	}
	else /* 默认按0处理：无过采样 */
	{
		AD7606_OS2_L;
		AD7606_OS1_L;
		AD7606_OS0_L;
	}
}

static uint16_t AD7606_Read16(void)
{
	uint16_t v = 0;
	for (uint8_t i = 0; i < 16; i++)
	{
		AD7606_SCLK_L;
		SPI_Delay();
		v <<= 1;
		if (READ_AD7606_DB7)
		{
			v |= 1u;
		}
		AD7606_SCLK_H;
		SPI_Delay();
	}
	return v;
}

void AD7606_ReadRaw8(uint16_t raw[8])
{
	if (!raw)
	{
		return;
	}
	AD7606_CS_L;
	for (uint8_t i = 0; i < 8; i++)
	{
		raw[i] = AD7606_Read16();
	}
	AD7606_CS_H;
}

/*
*********************************************************************************************************
* 函 数 名: AD7606_Reset
* 功能说明: 硬件复位操作
* 形    参: 无
* 返 回 值: 无
* 说    明: AD7606复位引脚为高电平有效 (Active High)。
* 时序要求：RESET高电平脉冲宽度至少为50ns。
*********************************************************************************************************
*/
void AD7606_Reset(void)
{
	/* 复位期间，建议将通信引脚置于空闲状态 */
	AD7606_CS_H;
	AD7606_SCLK_H;

	/* 产生复位脉冲：低 -> 高 -> 低 */
	AD7606_REST_L;
	AD7606_REST_L; // 稍微延时确保低电平

	AD7606_REST_H; // 拉高RESET，开始复位
	AD7606_REST_H; // 保持高电平，确保满足最小脉宽要求(>50ns)
	AD7606_REST_H;
	AD7606_REST_H;

	AD7606_REST_L; // 拉低RESET，结束复位，芯片开始工作
	AD7606_REST_L;
}

/*
*********************************************************************************************************
* 函 数 名: AD7606_StartConv
* 功能说明: 启动AD7606的ADC转换 (Sample & Hold)
* 形    参: 无
* 返 回 值: 无
* 说    明: 在CONVST引脚的上升沿启动转换。
* 时序要求：CONVST低电平脉宽至少25ns。
*********************************************************************************************************
*/
void AD7606_StartConv(void)
{
	/* 1. 先拉低CONVST A和B */
	AD7606_CONVEST_A_L;
	AD7606_CONVEST_B_L;

	/* 2. 延时，保证低电平持续时间满足要求 (代码中使用多条指令执行来充当微小延时) */
	// WAD7606_CONVEST_A(0); ... (原有的注释掉的延时代码)

	/* 3. 拉高CONVST，产生上升沿，AD7606开始采集并转换所有通道 */
	AD7606_CONVEST_A_H;
	AD7606_CONVEST_B_H;
}

/*
*********************************************************************************************************
* 函 数 名: ADRED_AD7606
* 功能说明: (已注释/备用) 硬件SPI方式读取函数
* 说    明: 当前主要使用软件模拟时序，此函数看似未启用
*********************************************************************************************************
*/
uint16_t ADRED_AD7606()
{

	uint16_t data;

	AD7606_CS_L; // 片选选中

	// data=SPI1_ReadWriteByte(0xff); // 发送空字节读取数据

	AD7606_CS_H;		// 取消片选
	AD7606_StartConv(); // 读取后立即启动下一次转换
	return data;
	// if(BUSY_IS_LOW()){}
	// return 123;
}

/*
*********************************************************************************************************
* 函 数 名: AD7606_read_data
* 功能说明: 手动模拟SPI时序读取数据 (主要读取函数)
* 形    参: DB_data - 存储读取结果的数组指针
* 返 回 值: 无
* 说    明:
* 1. 该函数目前循环 `i<1`，似乎只读取了第1个通道的数据。
* 2. 使用 `READ_AD7606_DB7` 作为数据输入引脚 (MISO)，即AD7606的串行输出模式。
* 3. 通过16次SCLK翻转，逐位移位读取16位ADC结果。
*********************************************************************************************************
*/
void AD7606_read_data(uint16_t *DB_data)
{
	AD7606_ReadRaw8(DB_data);
}

/* 开关全局中断的宏定义，用于保护临界区 */
#define ENABLE_INT() __set_PRIMASK(0)  /* 使能全局中断 */
#define DISABLE_INT() __set_PRIMASK(1) /* 禁止全局中断 */

/*
*********************************************************************************************************
* 函 数 名: AD7606_ReadAdc
* 功能说明: (保留接口) 从FIFO或缓冲区中读取一个ADC值
* 形    参: _ch : 通道号
* 返 回 值: ADC数值
* 说    明: 当前函数体被注释，返回未赋值变量，需根据实际需求完善
*********************************************************************************************************
*/
int16_t AD7606_ReadAdc(uint8_t _ch)
{
	int16_t sAdc;

	//  DISABLE_INT();
	//  sAdc = s_adc_now[_ch]; // 假设有一个全局数组存放最新数据
	//  ENABLE_INT();

	return sAdc;
}

/*
*********************************************************************************************************
* 函 数 名: SPI_Read8Bit
* 功能说明: 软件模拟SPI读取8位数据
* 形    参: 无
* 返 回 值: 读取到的8位数据
* 说    明: SCK上升沿采集数据, SCK空闲时为高电平 (CPOL=1, CPHA=1 或 类似的模式)
*********************************************************************************************************
*/
uint8_t SPI_Read8Bit(void)
{
	uint8_t i;
	uint8_t read = 0;

	for (i = 0; i < 8; i++)
	{
		AD7606_SCLK_L;	  // 拉低时钟
		SPI_Delay();
		read = read << 1; // 数据左移，为新的一位腾出LSB位置

		/* 读取引脚状态 (假设READ_AD7606_DB7宏读取GPIO输入寄存器) */
		if (READ_AD7606_DB7)
		{
			read++; // 如果引脚为高，最低位置1
		}
		AD7606_SCLK_H; // 拉高时钟
		SPI_Delay();
	}
	return read;
}

/*
*********************************************************************************************************
* 函 数 名: AD7606_Scan
* 功能说明: 轮询/扫描读取函数
* 形    参: DB_data - 用于存放读取数据的数组
* 返 回 值: 无
* 说    明: 此函数包含完整的 状态检测 -> 读取 -> 启动下次转换 流程
*********************************************************************************************************
*/
void AD7606_Scan(uint16_t *DB_data) /* 此函数代码按照时序编写 */
{
	/*
	   修正后的逻辑：
	   1. BUSY 为高电平时，表示正在转换（OverSampling 模式下时间较长）。
	   2. 必须死循环等待直到 BUSY 变低（转换完成）。
	   3. BUSY 变低后，才开始 CS 拉低并读取数据。
	*/

	// ！！！核心修改点！！！：将原来的 if(BUSY) 改为 while(BUSY)
	while (READ_AD7606_BUSY)
		;

	// 程序运行到这，说明 BUSY 已经是低电平了（转换完成），可以读取
	{
		AD7606_ReadRaw8(DB_data);
		AD7606_StartConv(); /* 发送启动信号，开始下一次ADC转换 */
	}
}

/*
*********************************************************************************************************
* 原始码值换算接口
*********************************************************************************************************
*/
int16_t AD7606_RawToS16(uint16_t raw)
{
	/* AD7606 输出为 16bit 两补码 */
	return (int16_t)raw;
}

double AD7606_RawToVolts(uint16_t raw)
{
	const int16_t code = AD7606_RawToS16(raw);
	const float fs_v = AD7606_GetFullScaleVolts(); /* 满量程（V） */

	/* code = -32768..+32767 映射到 -FS..+(FS-1LSB) */
	const double vin_adc_v = ((double)code * (double)fs_v) / 32768.0;

	/* 把“ADC脚看到的电压”还原成“外部输入电压” */
	return vin_adc_v / (double)AD7606_FRONTEND_GAIN;
}

float AD7606_RawToVoltsF(uint16_t raw)
{
	const int16_t code = AD7606_RawToS16(raw);
	const float fs_v = AD7606_GetFullScaleVolts();
	const float vin_adc_v = ((float)code * fs_v) / 32768.0f;
	return vin_adc_v / AD7606_FRONTEND_GAIN;
}

void AD7606_GetStats(uint32_t *frames, uint32_t *miss)
{
	uint32_t primask = __get_PRIMASK();
	__disable_irq();
	if (frames) *frames = g_ad7606_frames;
	if (miss) *miss = g_ad7606_miss;
	__set_PRIMASK(primask);
}

{% extends "base.html" %}

{% block title %}å®æ—¶ç›‘æµ‹ - EdgeWind{% endblock %}
{% block page_title %}å®æ—¶ç›‘æµ‹{% endblock %}

{% block extra_css %}
<style>
    /* å®æ—¶ç›‘æµ‹é¡µé¢èƒŒæ™¯è‰² - æ›´æ·¡çš„è“è‰²è°ƒï¼Œä¸å½±å“æ³¢å½¢è§‚çœ‹ */
    body {
        background: radial-gradient(circle at 50% -20%, #2d5a8a 0%, #1a2d4a 100%) fixed !important;
        background-color: #1a2d4a !important;
    }
    
    .main-content {
        background: transparent !important;
    }

    /* æ•…éšœæ—¥å¿—ï¼šæœªå¤„ç†çº¢ç‚¹æ ‡è®°ï¼ˆå°½é‡è½»é‡ï¼Œé¿å…å†…è”æ ·å¼ï¼‰ */
    .ws-fault-dot {
        width: 8px;
        height: 8px;
        display: inline-block;
        border-radius: 50%;
        vertical-align: middle;
    }

    /* é˜ˆå€¼å‘Šè­¦çº¢ç‚¹ï¼ˆå¤ç”¨åŒä¸€å°ºå¯¸ï¼Œé¿å…å¼•å…¥é¢å¤–è‡ªå®šä¹‰æ ·å¼ä½“ç³»ï¼‰ */
    .ws-alarm-dot {
        width: 8px;
        height: 8px;
        display: inline-block;
        border-radius: 50%;
        vertical-align: middle;
    }
</style>
{% endblock %}

{% block content %}
<div class="row">
    <!-- å·¦ä¾§ï¼šè¾¹ç¼˜èŠ‚ç‚¹åˆ—è¡¨ (ä¾§è¾¹æ ) -->
    <div class="col-lg-3">
        <div class="card mb-3">
            <div class="card-header bg-dark text-white">
                <h6 class="mb-0">
                    <i class="bi bi-diagram-3"></i> è¾¹ç¼˜èŠ‚ç‚¹åˆ—è¡¨
                </h6>
            </div>
            <div class="card-body p-0">
                <div class="list-group list-group-flush" id="nodeList" style="max-height: 600px; overflow-y: auto;">
                    <!-- è¾¹ç¼˜èŠ‚ç‚¹åˆ—è¡¨å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
                    <div class="text-center text-muted py-4">
                        <i class="bi bi-hourglass-split"></i> åŠ è½½ä¸­...
                    </div>
                </div>
            </div>
        </div>
        
        <!-- æ€§èƒ½ç›‘æ§é¢æ¿ -->
        <div class="card border-success">
            <div class="card-header bg-success text-white py-2">
                <h6 class="mb-0 small">
                    <i class="bi bi-speedometer2"></i> æ€§èƒ½ç›‘æ§
                </h6>
            </div>
            <div class="card-body p-2">
                <div class="row g-2 small">
                    <div class="col-6">
                        <div class="text-muted">æ•°æ®åˆ·æ–°ç‡</div>
                        <div class="fw-bold text-success" id="perf-refresh-rate">-- Hz</div>
                    </div>
                    <div class="col-6">
                        <div class="text-muted">WebSocket</div>
                        <div class="fw-bold" id="perf-ws-status">
                            <span class="badge bg-secondary">æœªè¿æ¥</span>
                        </div>
                    </div>
                    <div class="col-6">
                        <div class="text-muted">è®¢é˜…èŠ‚ç‚¹</div>
                        <div class="fw-bold text-info" id="perf-subscribed-node">æ— </div>
                    </div>
                    <div class="col-6">
                        <div class="text-muted">æ¸²æŸ“å»¶è¿Ÿ</div>
                        <div class="fw-bold text-warning" id="perf-render-time">-- ms</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- å³ä¾§ï¼šä¸»å†…å®¹åŒº -->
    <div class="col-lg-9">
        <div class="row g-3 mb-4">
            <div class="col-md-3 col-6">
                <div class="card h-100 shadow-sm card-select card-active" id="card-voltage" 
                     onclick="selectSource('voltage')" style="border-top: 4px solid #0d6efd; cursor:pointer;">
                    <div class="card-body text-center p-3 d-flex flex-column justify-content-center">
                        <h6 class="text-muted small fw-bold mb-1">ç›´æµæ¯çº¿(+)
                            <span id="alarm-dot-voltage" class="ws-alarm-dot bg-danger ms-1 d-none" title="ç”µå‹è¶…è¿‡é˜ˆå€¼"></span>
                        </h6>
                        <h3 class="fw-bold text-primary mb-0" id="val-voltage">--</h3>
                        <small class="text-muted">V</small>
                        <div class="select-badge text-primary mt-2">
                            <i class="bi bi-check-circle-fill me-1"></i>å·²é€‰ä¸­
                        </div>
                </div>
            </div>
        </div>
        
            <div class="col-md-3 col-6">
                <div class="card h-100 shadow-sm card-select" id="card-voltage_neg" 
                     onclick="selectSource('voltage_neg')" style="border-top: 4px solid #dc3545; cursor:pointer;">
                    <div class="card-body text-center p-3 d-flex flex-column justify-content-center">
                        <h6 class="text-muted small fw-bold mb-1">ç›´æµæ¯çº¿(-)
                            <span id="alarm-dot-voltage-neg" class="ws-alarm-dot bg-danger ms-1 d-none" title="ç”µå‹è¶…è¿‡é˜ˆå€¼"></span>
                        </h6>
                        <h3 class="fw-bold text-danger mb-0" id="val-voltage-neg">--</h3>
                        <small class="text-muted">V</small>
                        <div class="select-badge text-danger mt-2">
                            <i class="bi bi-check-circle-fill me-1"></i>å·²é€‰ä¸­
                    </div>
                </div>
            </div>
        </div>

            <div class="col-md-3 col-6">
                <div class="card h-100 shadow-sm card-select" id="card-current" 
                     onclick="selectSource('current')" style="border-top: 4px solid #0dcaf0; cursor:pointer;">
                    <div class="card-body text-center p-3 d-flex flex-column justify-content-center">
                        <h6 class="text-muted small fw-bold mb-1">è´Ÿè½½ç”µæµ</h6>
                        <h3 class="fw-bold text-info mb-0" id="val-current">--</h3>
                        <small class="text-muted">A</small>
                        <div class="select-badge text-info mt-2">
                            <i class="bi bi-check-circle-fill me-1"></i>å·²é€‰ä¸­
                    </div>
                </div>
            </div>
        </div>

            <div class="col-md-3 col-6">
                <div class="card h-100 shadow-sm card-select" id="card-leakage" 
                     onclick="selectSource('leakage')" style="border-top: 4px solid #ffc107; cursor:pointer;">
                    <div class="card-body text-center p-3 d-flex flex-column justify-content-center">
                        <h6 class="text-muted small fw-bold mb-1">æ¼ç”µæµ
                            <span id="alarm-dot-leakage" class="ws-alarm-dot bg-danger ms-1 d-none" title="æ¼ç”µæµè¶…è¿‡é˜ˆå€¼"></span>
                        </h6>
                        <h3 class="fw-bold text-warning mb-0" id="val-leakage">--</h3>
                        <small class="text-muted">mA</small>
                        <div class="select-badge text-warning mt-2">
                            <i class="bi bi-check-circle-fill me-1"></i>å·²é€‰ä¸­
                    </div>
                </div>
            </div>
                    </div>
                </div>

        <!-- åº•éƒ¨ï¼šæ³¢å½¢ç›‘æ§ (æ ‡ç­¾é¡µç•Œé¢) -->
        <div class="card mb-3">
            <div class="card-header bg-dark text-white">
                <ul class="nav nav-tabs card-header-tabs border-0" role="tablist">
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active text-white" 
                                id="timeTab" 
                                data-bs-toggle="tab" 
                                data-bs-target="#timeChartPane" 
                                type="button" 
                                role="tab" 
                                aria-controls="timeChartPane" 
                                aria-selected="true"
                                onclick="switchChartTab('time')">
                            <i class="bi bi-graph-up"></i> æ—¶åŸŸåˆ†æ (Time Domain)
                        </button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link text-white" 
                                id="freqTab" 
                                data-bs-toggle="tab" 
                                data-bs-target="#freqChartPane" 
                                type="button" 
                                role="tab" 
                                aria-controls="freqChartPane" 
                                aria-selected="false"
                                onclick="switchChartTab('freq')">
                            <i class="bi bi-bar-chart"></i> é¢‘åŸŸåˆ†æ (FFT Spectrum)
                        </button>
                    </li>
                </ul>
            </div>
            <div class="card-body p-0">
                <div class="tab-content">
                    <!-- æ—¶åŸŸåˆ†ææ ‡ç­¾é¡µ -->
                    <div class="tab-pane fade show active" 
                         id="timeChartPane" 
                         role="tabpanel" 
                         aria-labelledby="timeTab">
                        <div class="card-body" id="time-domain-chart-container">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <small class="text-muted">
                                    <i class="bi bi-info-circle"></i> æç¤ºï¼šåŒå‡»Yè½´é‡ç½®Yè½´ï¼ŒåŒå‡»Xè½´é‡ç½®Xè½´ï¼ŒåŒå‡»å›¾è¡¨åŒºåŸŸé‡ç½®å…¨éƒ¨
                                </small>
                                <button class="btn btn-sm btn-outline-secondary" onclick="resetTimeDomainZoom()" title="é‡ç½®æ‰€æœ‰ç¼©æ”¾">
                                    <i class="bi bi-arrow-counterclockwise"></i> é‡ç½®ç¼©æ”¾
                                </button>
                    </div>
                            <!-- è§†è§‰ä¼˜åŒ–ï¼šæ—¶åŸŸæ³¢å½¢æ›´é«˜ä¸€äº›ï¼Œä¾¿äºè§‚å¯Ÿç»†èŠ‚ -->
                            <div id="time-domain-chart" style="width: 100%; height: 600px;"></div>
                </div>
            </div>
                    <!-- é¢‘åŸŸåˆ†ææ ‡ç­¾é¡µ -->
                    <div class="tab-pane fade" 
                         id="freqChartPane" 
                         role="tabpanel" 
                         aria-labelledby="freqTab">
                        <div class="card-body" id="frequency-domain-chart-container">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <small class="text-muted">
                                    <i class="bi bi-info-circle"></i> æç¤ºï¼šåŒå‡»Yè½´é‡ç½®Yè½´ï¼ŒåŒå‡»Xè½´é‡ç½®Xè½´ï¼ŒåŒå‡»å›¾è¡¨åŒºåŸŸé‡ç½®å…¨éƒ¨
                                </small>
                                <button class="btn btn-sm btn-outline-secondary" onclick="resetFrequencyDomainZoom()" title="é‡ç½®æ‰€æœ‰ç¼©æ”¾">
                                    <i class="bi bi-arrow-counterclockwise"></i> é‡ç½®ç¼©æ”¾
                                </button>
                            </div>
                            <!-- é¢‘åŸŸå›¾ä¸æ—¶åŸŸä¿æŒä¸€è‡´çš„é«˜åº¦ä¸äº¤äº’ -->
                            <div id="frequency-domain-chart" style="width: 100%; height: 600px;"></div>
            </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- æ•…éšœæ—¥å¿—è¡¨ -->
        <div class="card border-0 shadow-sm mt-4">
            <div class="card-header bg-white py-3">
                <h6 class="mb-0 fw-bold"><i class="bi bi-clock-history me-2"></i>ç³»ç»Ÿæ•…éšœæ—¥å¿—</h6>
            </div>
            <div class="card-body p-0">
                <div class="table-responsive" style="max-height: 300px; overflow-y: auto;">
                    <table class="table table-hover align-middle mb-0">
                        <thead class="table-light sticky-top">
                            <tr>
                                <th>æ—¶é—´</th>
                                <th>è¾¹ç¼˜èŠ‚ç‚¹ID</th>
                                <th>çŠ¶æ€ç </th>
                                <th>è¯¦ç»†ä¿¡æ¯</th>
                            </tr>
                        </thead>
                        <tbody id="fault-log-body">
                            <!-- æ—¥å¿—æ¡ç›®å°†é€šè¿‡JavaScriptåŠ¨æ€æ·»åŠ  -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<!-- åŠ ç‰ˆæœ¬å·é¿å…æµè§ˆå™¨ç¼“å­˜å¯¼è‡´â€œæ”¹äº†æ²¡æ•ˆæœâ€ -->
<script src="{{ url_for('static', filename='js/chart-zoom-utils.js') }}?v=20260107_7"></script>
<script>
    // ========== åŠ¨æ€è¾¹ç¼˜èŠ‚ç‚¹é…ç½® (ä»åç«¯å®æ—¶è·å–) ==========
    let NODE_CONFIGS = {};  // ä»åç«¯APIåŠ¨æ€è·å–
    let isFirstLoad = true;  // æ ‡è®°æ˜¯å¦ä¸ºé¦–æ¬¡åŠ è½½
    let autoFocusHandled = false;  // æ ‡è®°æ˜¯å¦å·²å¤„ç†è‡ªåŠ¨èšç„¦
    
    // ========== WebSocket è¿æ¥ ==========
    let socket = null;

    // ========== è¾…åŠ©å‡½æ•°ï¼šè·å–URLæŸ¥è¯¢å‚æ•° ==========
    function getQueryParam(param) {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get(param);
    }

    // ========== å…¨å±€çŠ¶æ€ ==========
    let currentNodeId = null;
    // Global State: Default to viewing positive voltage
    let currentSource = 'voltage';
    let currentChannelIndex = 0;
    let nodeData = {};
    let timeDomainChart = null;
    let frequencyDomainChart = null;
    let updateInterval = null;
    let nodeListInterval = null;
    let activeTab = 'time';  // å½“å‰æ¿€æ´»çš„æ ‡ç­¾é¡µï¼š'time' æˆ– 'freq'
    let lastCachedData = null;  // å…³é”®ä¿®å¤ï¼šç¼“å­˜æœ€æ–°æ•°æ®åŒ…ï¼Œç”¨äºå³æ—¶åˆ‡æ¢
    let nodeFaultHistory = {};  // å­˜å‚¨æ¯ä¸ªè¾¹ç¼˜èŠ‚ç‚¹çš„æœ€åå·²çŸ¥æ•…éšœä»£ç ï¼š{ "STM32_Node_001": "E00" }

    // ========== æŠ¥è­¦é˜ˆå€¼ï¼ˆæ¥è‡ªç³»ç»Ÿè®¾ç½®ï¼‰==========
    // è¯´æ˜ï¼š
    // - è®¾ç½®é¡µä¿å­˜é”®ï¼švoltage_max / leakage_threshold
    // - è¿™é‡Œç”¨äºâ€œè¶…é˜ˆå€¼æç¤ºâ€ï¼ˆçº¢ç‚¹ + äº‹ä»¶æç¤ºï¼‰ï¼Œä¸æ”¹å˜é¡¹ç›®å®šä¹‰çš„ E01-E05 æ•…éšœç é€»è¾‘
    const alarmThresholds = {
        voltageMax: 400,        // V
        leakageThreshold: 30    // mA
    };
    const alarmState = {
        voltageHighPos: false,
        voltageHighNeg: false,
        leakageHigh: false
    };
    // æ•…éšœæ—¥å¿—ï¼šæ˜¯å¦å·²ä»åç«¯å›å¡«å†å²è®°å½•ï¼ˆé¿å…â€œé•¿æœŸç©ºç™½â€ï¼‰
    let faultLogHistoryLoaded = false;
    // æ•…éšœæ—¥å¿—ï¼šç»Ÿä¸€ç»´æŠ¤ä¸€ä»½â€œå¯æ’åºçš„åˆ—è¡¨â€ï¼Œé¿å…ç›´æ¥ DOM insert å¯¼è‡´é¡ºåºä¸å¯æ§
    // key ä¼˜å…ˆç”¨å·¥å• idï¼›æ²¡æœ‰ id æ—¶ä½¿ç”¨ `${timeStr}|${nodeId}|${faultCode}`
    // é‡è¦ï¼šåŒä¸€å·¥å•çŠ¶æ€å˜åŒ–ï¼ˆpending->processing->resolvedï¼‰å¿…é¡»â€œæ›´æ–°åŒä¸€æ¡è®°å½•â€ï¼Œä¸èƒ½è¢«å»é‡æŒ¡ä½ã€‚
    const faultLogMap = new Map();  // key -> {id,nodeId,faultCode,timeStr,status,tsMs}

    function normalizeFaultStatus(status) {
        const s = String(status || '').trim().toLowerCase();
        if (!s) return 'pending';
        if (s === 'fixed') return 'resolved';
        if (s === 'resolved') return 'resolved';
        if (s === 'processing') return 'processing';
        if (s === 'pending') return 'pending';
        return 'pending';
    }

    function statusRank(status) {
        // æœªå¤„ç† -> å¤„ç†ä¸­ -> å·²å¤„ç†
        const s = normalizeFaultStatus(status);
        if (s === 'pending') return 0;
        if (s === 'processing') return 1;
        return 2; // resolved
    }

    function statusBadge(status) {
        const s = normalizeFaultStatus(status);
        if (s === 'pending') return { text: 'æœªå¤„ç†', cls: 'bg-danger' };
        if (s === 'processing') return { text: 'å¤„ç†ä¸­', cls: 'bg-warning text-dark' };
        return { text: 'å·²å¤„ç†', cls: 'bg-success' };
    }

    function parseBeijingTimeToMs(timeStr) {
        // å…¼å®¹ï¼štimeStr å¯èƒ½æ˜¯ "YYYY-MM-DD HH:MM:SS"ï¼ˆåŒ—äº¬æ—¶é—´ï¼‰æˆ– ISO
        const t = String(timeStr || '').trim();
        if (!t) return 0;
        // ISO
        const iso = Date.parse(t);
        if (!Number.isNaN(iso)) return iso;
        // "YYYY-MM-DD HH:MM:SS" -> ISO +08:00ï¼ˆé¿å…æœ¬æœºæ—¶åŒºå½±å“ï¼‰
        const norm = t.replace(' ', 'T') + '+08:00';
        const ms = Date.parse(norm);
        return Number.isNaN(ms) ? 0 : ms;
    }

    function renderFaultLogTable(limit = 50) {
        const tbody = document.getElementById('fault-log-body');
        if (!tbody) return;

        const rows = Array.from(faultLogMap.values());
        rows.sort((a, b) => {
            const ra = statusRank(a.status);
            const rb = statusRank(b.status);
            if (ra !== rb) return ra - rb;
            // åŒä¸€çŠ¶æ€å†…ï¼šæŒ‰æ—¶é—´æ’åºï¼ˆé»˜è®¤æœ€æ–°åœ¨å‰ï¼‰
            return (b.tsMs || 0) - (a.tsMs || 0);
        });

        const top = rows.slice(0, limit);
        tbody.innerHTML = '';

        if (top.length === 0) {
            renderFaultLogEmptyState();
            return;
        }

        for (const it of top) {
            const { nodeId, faultCode, timeStr, status } = it;
            const deviceId = nodeId;
            const ts = String(timeStr || '').trim();
            const canJump = faultCode && faultCode !== 'E00' && deviceId && ts;
            const jumpUrl = canJump
                ? `/snapshots?device_id=${encodeURIComponent(deviceId)}&fault_code=${encodeURIComponent(faultCode)}&timestamp=${encodeURIComponent(ts)}`
                : '';

            const faultNames = {
                "E00": "ç³»ç»Ÿæ­£å¸¸",
                "E01": "äº¤æµçªœå…¥",
                "E02": "ç»ç¼˜æ•…éšœ",
                "E03": "ç”µå®¹è€åŒ–",
                "E04": "IGBTå¼€è·¯",
                "E05": "æ¥åœ°æ•…éšœ"
            };
            const msg = faultNames[faultCode] || `æœªçŸ¥æ•…éšœ (${faultCode})`;
            const isFault = faultCode !== 'E00';
            const codeBadgeClass = isFault ? 'bg-danger' : 'bg-success';

            const st = statusBadge(status);
            const dotHtml = (normalizeFaultStatus(status) === 'pending')
                ? `<span class="ws-fault-dot bg-danger me-1" title="æœªå¤„ç†"></span>`
                : ``;

            const tr = document.createElement('tr');
            // å®‰å…¨ï¼štimeStr/nodeId/msg å‡å¯èƒ½æ¥è‡ªæ•°æ®åº“/è®¾å¤‡ä¸ŠæŠ¥ï¼Œæ¸²æŸ“åˆ° innerHTML å‰å¿…é¡»åš HTML è½¬ä¹‰
            const safeTime = escapeHtml(timeStr);
            const safeNodeId = escapeHtml(nodeId);
            const safeMsg = escapeHtml(msg);
            const safeCode = escapeHtml(faultCode);
            tr.innerHTML = `
                <td>${safeTime}</td>
                <td>${safeNodeId}</td>
                <td>
                    ${dotHtml}
                    ${canJump ? `<a href="${jumpUrl}" class="text-decoration-none" title="ç‚¹å‡»è·³è½¬æ•…éšœå¿«ç…§">
                        <span class="badge ${codeBadgeClass}">${safeCode}</span>
                    </a>` : `<span class="badge ${codeBadgeClass}">${safeCode}</span>`}
                    <span class="badge ${st.cls} ms-2">${st.text}</span>
                </td>
                <td>
                    ${safeMsg}
                    ${canJump ? `<a href="${jumpUrl}" class="ms-2 small text-primary text-decoration-none" title="æŸ¥çœ‹æ•…éšœå¿«ç…§">
                        <i class="bi bi-camera"></i> å¿«ç…§
                    </a>` : ''}
                </td>
            `;
            tbody.appendChild(tr);
        }
    }

    // ========== å¤„ç†URLå‚æ•°ï¼ˆä»å…¨å±€æœç´¢è·³è½¬ï¼‰ ==========
    let pendingNodeSelection = null;  // å­˜å‚¨å¾…é€‰æ‹©çš„è¾¹ç¼˜èŠ‚ç‚¹ID
    
    function handleURLParams() {
        const urlParams = new URLSearchParams(window.location.search);
        
        // 1. å¤„ç†è¾¹ç¼˜èŠ‚ç‚¹é€‰æ‹©
        const selectNodeId = urlParams.get('select');
        if (selectNodeId) {
            pendingNodeSelection = selectNodeId;
            // å°è¯•ç«‹å³é€‰æ‹©ï¼ˆå¦‚æœæ•°æ®å·²åŠ è½½ï¼‰
            trySelectPendingNode();
        }
        
        // 2. å¤„ç†æ ‡ç­¾é¡µåˆ‡æ¢
        const tab = urlParams.get('tab');
        if (tab === 'time' || tab === 'fft') {
            // å»¶è¿Ÿæ‰§è¡Œï¼Œç¡®ä¿é¡µé¢å·²å®Œå…¨åŠ è½½
            setTimeout(() => {
                switchChartTab(tab === 'fft' ? 'freq' : 'time');
            }, 300);
        }
        
        // 3. å¤„ç†é€šé“é€‰æ‹©
        const channel = urlParams.get('channel');
        if (channel !== null) {
            const channelIndex = parseInt(channel);
            if (!isNaN(channelIndex) && channelIndex >= 0 && channelIndex < 4) {
                // å»¶è¿Ÿæ‰§è¡Œï¼Œç¡®ä¿è¾¹ç¼˜èŠ‚ç‚¹å·²é€‰æ‹©
                setTimeout(() => {
                    if (currentNodeId) {
                        selectChannel(channelIndex);
                    }
                }, 500);
            }
        }
        
        // 4. å¤„ç†ä¾§è¾¹æ èšç„¦
        const focus = urlParams.get('focus');
        if (focus === 'sidebar') {
            const nodeListGroup = document.getElementById('nodeList');
            if (nodeListGroup) {
                // æ·»åŠ é«˜äº®åŠ¨ç”»æ•ˆæœ
                nodeListGroup.style.transition = 'all 0.3s ease';
                nodeListGroup.style.boxShadow = '0 0 20px rgba(37, 99, 235, 0.5)';
                nodeListGroup.style.border = '2px solid #2563eb';
                
                // æ»šåŠ¨åˆ°è¾¹ç¼˜èŠ‚ç‚¹åˆ—è¡¨
                nodeListGroup.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                
                // 3ç§’åç§»é™¤é«˜äº®
                setTimeout(() => {
                    nodeListGroup.style.boxShadow = '';
                    nodeListGroup.style.border = '';
                }, 3000);
            }
        }
        
        // æ¸…é™¤URLå‚æ•°ï¼ˆä½†ä¸åŒ…æ‹¬focus=faultï¼Œå› ä¸ºå®ƒéœ€è¦åœ¨æ•°æ®åŠ è½½åå¤„ç†ï¼‰
        const hasParams = selectNodeId || tab || channel !== null || (focus && focus !== 'fault');
        if (hasParams) {
            window.history.replaceState({}, '', '/monitor');
        }
    }
    
    // å°è¯•é€‰æ‹©å¾…é€‰æ‹©çš„è¾¹ç¼˜èŠ‚ç‚¹ï¼ˆåœ¨è¾¹ç¼˜èŠ‚ç‚¹æ•°æ®åŠ è½½åè°ƒç”¨ï¼‰
    function trySelectPendingNode() {
        if (pendingNodeSelection && NODE_CONFIGS && Object.keys(NODE_CONFIGS).length > 0) {
            const nodeId = pendingNodeSelection;
            if (NODE_CONFIGS[nodeId]) {
                selectNode(nodeId);
                pendingNodeSelection = null;  // æ¸…é™¤å¾…é€‰æ‹©æ ‡è®°
                console.log(`âœ… å·²è‡ªåŠ¨é€‰æ‹©è¾¹ç¼˜èŠ‚ç‚¹: ${nodeId}`);
            } else {
                console.warn(`âš ï¸ è¾¹ç¼˜èŠ‚ç‚¹ ${nodeId} ä¸å­˜åœ¨æˆ–æœªåœ¨çº¿`);
                pendingNodeSelection = null;  // æ¸…é™¤æ— æ•ˆçš„å¾…é€‰æ‹©æ ‡è®°
            }
        }
    }

    // ========== åˆå§‹åŒ– ==========
    document.addEventListener('DOMContentLoaded', function() {
        timeDomainChart = echarts.init(document.getElementById('time-domain-chart'));
        frequencyDomainChart = echarts.init(document.getElementById('frequency-domain-chart'));

        // åˆå§‹åŒ–é…ç½®æ ‡è®°
        if (timeDomainChart) {
            timeDomainChart._configInitialized = false;
        }
        if (frequencyDomainChart) {
            frequencyDomainChart._configInitialized = false;
        }

        // è®¾ç½®ç¤ºæ³¢å™¨å¼äº¤äº’ï¼ˆè½´ç‹¬ç«‹ç¼©æ”¾ï¼‰- ä½¿ç”¨ç»Ÿä¸€çš„ç¼©æ”¾å·¥å…·å‡½æ•°
        const timeChartDom = document.getElementById('time-domain-chart');
        if (timeDomainChart && timeChartDom) {
            setupChartZoom(timeDomainChart, timeChartDom);
            timeChartDom._zoomApplied = true;
        }

        // é¢‘åŸŸå›¾ä¹Ÿå¯ç”¨åŒæ ·çš„ç¼©æ”¾/æ‹–æ‹½äº¤äº’ï¼ˆä¸æ—¶åŸŸä¿æŒä¸€è‡´ï¼‰
        const freqChartDom = document.getElementById('frequency-domain-chart');
        if (frequencyDomainChart && freqChartDom) {
            setupChartZoom(frequencyDomainChart, freqChartDom);
            freqChartDom._zoomApplied = true;
        }
        
        // æ£€æŸ¥æ˜¯å¦æœ‰ä»ç³»ç»Ÿæ¦‚è§ˆé¡µé¢ä¼ æ¥çš„èŠ‚ç‚¹ID
        const selectedNodeId = localStorage.getItem('selectedNodeId');
        if (selectedNodeId) {
            console.log(`ğŸ“ æ£€æµ‹åˆ°ä»ç³»ç»Ÿæ¦‚è§ˆä¼ æ¥çš„èŠ‚ç‚¹ID: ${selectedNodeId}`);
            pendingNodeSelection = selectedNodeId;
            // æ¸…é™¤localStorageï¼Œé¿å…ä¸‹æ¬¡è¿›å…¥æ—¶è¯¯é€‰
            localStorage.removeItem('selectedNodeId');
        }
        
        // é¦–æ¬¡åŠ è½½æ´»åŠ¨è¾¹ç¼˜èŠ‚ç‚¹
        fetchActiveNodes();
        initializeAllNodeData();
        
        // åˆå§‹åŒ–è¾¹ç¼˜èŠ‚ç‚¹åˆ—è¡¨
        renderNodeList();

        // å¤„ç†URLå‚æ•°ï¼ˆå…¨å±€æœç´¢è·³è½¬ï¼‰
        handleURLParams();

        // åˆå§‹åŒ–WebSocketè¿æ¥ï¼ˆæ›¿ä»£è½®è¯¢ï¼‰
        initWebSocket();

        // åŠ è½½ç³»ç»Ÿè®¾ç½®çš„æŠ¥è­¦é˜ˆå€¼ï¼ˆç”¨äºâ€œè¶…é˜ˆå€¼çº¢ç‚¹/æç¤ºâ€ï¼‰
        loadAlarmThresholds();

        // æ•…éšœæ—¥å¿—ï¼šåŠ è½½å†å²è®°å½•ï¼Œé¿å…è¡¨æ ¼é•¿æœŸç©ºç™½
        loadFaultLogHistory();
        // æ•…éšœæ—¥å¿—ï¼šè½®è¯¢å…œåº•ï¼ˆè¦†ç›– /api/upload ç­‰ä¸æ¨é€ WebSocket çš„é“¾è·¯ï¼‰
        startFaultLogPolling();

        // ç›‘å¬Bootstrapæ ‡ç­¾é¡µåˆ‡æ¢äº‹ä»¶ï¼ˆBootstrap 5äº‹ä»¶ç»‘å®šåœ¨æŒ‰é’®ä¸Šï¼‰
        const timeTab = document.getElementById('timeTab');
        const freqTab = document.getElementById('freqTab');
        
        if (timeTab) {
            timeTab.addEventListener('shown.bs.tab', function() {
                activeTab = 'time';
                setTimeout(() => {
                    if (timeDomainChart) timeDomainChart.resize();
                }, 150);
                updateCharts();
            });
        }
        
        if (freqTab) {
            freqTab.addEventListener('shown.bs.tab', function() {
                activeTab = 'freq';
                setTimeout(() => {
                    if (frequencyDomainChart) frequencyDomainChart.resize();
                }, 150);
                updateCharts();
            });
        }
        
        window.addEventListener('resize', function() {
            // åªè°ƒæ•´å½“å‰å¯è§çš„å›¾è¡¨
            if (activeTab === 'time' && timeDomainChart) {
                timeDomainChart.resize();
            } else if (activeTab === 'freq' && frequencyDomainChart) {
                frequencyDomainChart.resize();
            }
        });
    });

    // ========== ä»ç³»ç»Ÿè®¾ç½®è¯»å–æŠ¥è­¦é˜ˆå€¼ï¼ˆä¼˜å…ˆæœåŠ¡å™¨ï¼Œå…¶æ¬¡ localStorageï¼‰==========
    async function loadAlarmThresholds() {
        // 1) æœåŠ¡å™¨ä¼˜å…ˆï¼ˆä¸ settings.html å¯¹é½ï¼‰
        try {
            const resp = await fetch('/api/admin/config', { method: 'GET' });
            if (resp.ok) {
                const result = await resp.json();
                if (result && result.success && result.data) {
                    const cfg = result.data;
                    if (cfg.voltage_max !== undefined && cfg.voltage_max !== null) {
                        const v = Number(cfg.voltage_max);
                        if (Number.isFinite(v) && v > 0) alarmThresholds.voltageMax = v;
                    }
                    if (cfg.leakage_threshold !== undefined && cfg.leakage_threshold !== null) {
                        const v = Number(cfg.leakage_threshold);
                        if (Number.isFinite(v) && v >= 0) alarmThresholds.leakageThreshold = v;
                    }
                    console.log('[AlarmThresholds] å·²ä»æœåŠ¡å™¨åŠ è½½:', alarmThresholds);
                    return;
                }
            }
        } catch (e) {
            console.warn('[AlarmThresholds] ä»æœåŠ¡å™¨åŠ è½½å¤±è´¥ï¼Œå›é€€æœ¬åœ°:', e);
        }

        // 2) æœ¬åœ°å…œåº•ï¼ˆsettings.html ä¼šå†™å…¥ localStorageï¼‰
        try {
            const v1 = Number(localStorage.getItem('voltLimit'));
            if (Number.isFinite(v1) && v1 > 0) alarmThresholds.voltageMax = v1;
            const v2 = Number(localStorage.getItem('currLimit'));
            if (Number.isFinite(v2) && v2 >= 0) alarmThresholds.leakageThreshold = v2;
            console.log('[AlarmThresholds] å·²ä»æœ¬åœ°åŠ è½½:', alarmThresholds);
        } catch (e) {}
    }

    // ========== é˜ˆå€¼å‘Šè­¦ï¼ˆçº¢ç‚¹ + æç¤ºï¼‰==========
    function applyThresholdAlarms(d) {
        // ç”µå‹ï¼šç”¨ç›´æµæ¯çº¿(+)åšä¸Šé™åˆ¤å®š
        const voltage = Number(d && d.voltage !== undefined ? d.voltage : 0);
        const voltageNeg = Number(d && d.voltage_neg !== undefined ? d.voltage_neg : 0);
        const leakage = Number(d && d.leakage !== undefined ? d.leakage : 0);

        const voltageHighPos = Number.isFinite(voltage) && voltage > alarmThresholds.voltageMax;
        // è´Ÿæ¯çº¿ï¼šæŒ‰å¹…å€¼åˆ¤æ–­ï¼ˆç­‰ä»·äº voltageNeg < -voltageMaxï¼‰
        const voltageHighNeg = Number.isFinite(voltageNeg) && (Math.abs(voltageNeg) > alarmThresholds.voltageMax);
        const leakageHigh = Number.isFinite(leakage) && leakage > alarmThresholds.leakageThreshold;

        // UIï¼šçº¢ç‚¹æ˜¾ç¤º/éšè—
        const dotV = document.getElementById('alarm-dot-voltage');
        if (dotV) dotV.classList.toggle('d-none', !voltageHighPos);
        const dotVn = document.getElementById('alarm-dot-voltage-neg');
        if (dotVn) dotVn.classList.toggle('d-none', !voltageHighNeg);
        const dotL = document.getElementById('alarm-dot-leakage');
        if (dotL) dotL.classList.toggle('d-none', !leakageHigh);

        // äº‹ä»¶æç¤ºï¼šåªåœ¨â€œçŠ¶æ€å˜åŒ–â€æ—¶æç¤ºï¼Œé¿å…åˆ·å±
        if (voltageHighPos !== alarmState.voltageHighPos) {
            alarmState.voltageHighPos = voltageHighPos;
            if (typeof window.publishSystemEvent === 'function') {
                if (voltageHighPos) {
                    window.publishSystemEvent(`âš ï¸ ç›´æµæ¯çº¿(+)ç”µå‹è¶…é™ï¼š${voltage.toFixed(2)}V > é˜ˆå€¼${alarmThresholds.voltageMax}V`, 'warning');
                } else {
                    window.publishSystemEvent(`âœ… ç›´æµæ¯çº¿(+)ç”µå‹å·²æ¢å¤ï¼š${voltage.toFixed(2)}V`, 'success');
                }
            }
        }

        if (voltageHighNeg !== alarmState.voltageHighNeg) {
            alarmState.voltageHighNeg = voltageHighNeg;
            if (typeof window.publishSystemEvent === 'function') {
                if (voltageHighNeg) {
                    window.publishSystemEvent(`âš ï¸ ç›´æµæ¯çº¿(-)ç”µå‹è¶…é™ï¼š${voltageNeg.toFixed(2)}Vï¼ˆå¹…å€¼>${alarmThresholds.voltageMax}Vï¼‰`, 'warning');
                } else {
                    window.publishSystemEvent(`âœ… ç›´æµæ¯çº¿(-)ç”µå‹å·²æ¢å¤ï¼š${voltageNeg.toFixed(2)}V`, 'success');
                }
            }
        }

        if (leakageHigh !== alarmState.leakageHigh) {
            alarmState.leakageHigh = leakageHigh;
            if (typeof window.publishSystemEvent === 'function') {
                if (leakageHigh) {
                    window.publishSystemEvent(`âš ï¸ æ¼ç”µæµè¶…é™ï¼š${leakage.toFixed(3)}mA > é˜ˆå€¼${alarmThresholds.leakageThreshold}mA`, 'warning');
                } else {
                    window.publishSystemEvent(`âœ… æ¼ç”µæµå·²æ¢å¤ï¼š${leakage.toFixed(3)}mA`, 'success');
                }
            }
        }
    }

    // ========== è·å–æ´»åŠ¨è¾¹ç¼˜èŠ‚ç‚¹ (å¿ƒè·³å‘ç°ç³»ç»Ÿ) ==========
    // æ³¨æ„ï¼šè¾¹ç¼˜èŠ‚ç‚¹æ³¨å†Œ/æ³¨é”€é€šçŸ¥å·²ç§»è‡³å…¨å±€è„šæœ¬ï¼ˆbase.htmlï¼‰ï¼Œè¿™é‡Œåªè´Ÿè´£ç›‘æµ‹é¡µé¢çš„æ•°æ®æ›´æ–°
    
    async function fetchActiveNodes() {
        try {
            const response = await fetch('/api/get_active_nodes');
            
            // å¤„ç† HTTP é”™è¯¯ï¼ˆ500, 404 ç­‰ï¼‰
            if (!response.ok) {
                // ç™»å½•æ€è¿‡æœŸï¼šåç«¯ä¼šå¯¹ /api/* è¿”å› 401 JSONï¼ˆä¸ä¼š 302 è·³è½¬ï¼‰
                // å¦‚æœä¸å¤„ç†ï¼Œå‰ç«¯ä¼šè¡¨ç°ä¸ºâ€œèŠ‚ç‚¹åœæœº/ä¸€ç›´ç­‰å¾…â€ï¼Œä½†å®é™…ä¸Šæ˜¯éœ€è¦é‡æ–°ç™»å½•ã€‚
                if (response.status === 401) {
                    console.warn('[fetchActiveNodes] 401 æœªç™»å½•æˆ–ç™»å½•æ€å¤±æ•ˆï¼Œè·³è½¬ç™»å½•é¡µ');
                    try {
                        const next = encodeURIComponent(window.location.pathname + window.location.search);
                        window.location.href = `/login?next=${next}`;
                    } catch (e) {
                        window.location.href = '/login';
                    }
                    return;
                }
                console.error(`[fetchActiveNodes] HTTPé”™è¯¯: ${response.status} ${response.statusText}`);
                // å³ä½¿å‡ºé”™ä¹Ÿç»§ç»­è½®è¯¢ï¼Œä¸ä¸­æ–­
                return;
            }

            // å…¼å®¹ï¼šç™»å½•å¤±æ•ˆæ—¶å¯èƒ½è¿”å› HTMLï¼ˆé‡å®šå‘åˆ°ç™»å½•é¡µï¼‰ï¼Œé¿å… response.json() æŠ›é”™å¯¼è‡´è½®è¯¢ä¸­æ–­
            const ct = (response.headers.get('Content-Type') || '').toLowerCase();
            if (!ct.includes('application/json')) {
                console.warn('[fetchActiveNodes] å“åº”éJSONï¼Œå¯èƒ½ç™»å½•å·²å¤±æ•ˆï¼Œè·³è¿‡æœ¬è½®æ›´æ–°');
                return;
            }

            const result = await response.json();
            
            if (!result.success) {
                console.error('[fetchActiveNodes] APIè¿”å›å¤±è´¥:', result.error);
                // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
                if (timeDomainChart && !timeDomainChart._loadingShown) {
                    timeDomainChart.showLoading('default', {
                        text: 'è·å–æ•°æ®ä¸­...',
                        color: '#0d6efd',
                        textColor: '#666',
                        maskColor: 'rgba(255, 255, 255, 0.8)',
                        zlevel: 0
                    });
                    timeDomainChart._loadingShown = true;
                }
                if (frequencyDomainChart && !frequencyDomainChart._loadingShown) {
                    frequencyDomainChart.showLoading('default', {
                        text: 'è·å–æ•°æ®ä¸­...',
                        color: '#8e44ad',
                        textColor: '#666',
                        maskColor: 'rgba(255, 255, 255, 0.8)',
                        zlevel: 0
                    });
                    frequencyDomainChart._loadingShown = true;
                }
                // å³ä½¿å‡ºé”™ä¹Ÿç»§ç»­è½®è¯¢ï¼Œä¸ä¸­æ–­
                return;
            }
            
            // æˆåŠŸè·å–æ•°æ®ï¼Œæ¸…é™¤åŠ è½½çŠ¶æ€æ ‡å¿—
            if (timeDomainChart) {
                timeDomainChart._loadingShown = false;
            }
            if (frequencyDomainChart) {
                frequencyDomainChart._loadingShown = false;
            }
            
            const nodes = result.nodes || [];
            
            // æ³¨æ„ï¼šä¸å†åœ¨è¿™é‡Œè°ƒç”¨ syncNodeEventsï¼Œå› ä¸ºå…¨å±€ç›‘æ§å·²ç»åœ¨ base.html ä¸­å¤„ç†
            
            // å°†åç«¯æ•°æ®è½¬æ¢ä¸ºå‰ç«¯æ ¼å¼
            const newConfigs = {};
            nodes.forEach(node => {
                const nodeId = node.node_id || node.device_id;
                if (!nodeId) return;
                
                // è½¬æ¢é€šé“æ•°æ®æ ¼å¼ï¼ˆä»åç«¯æ¥æ”¶å®Œæ•´æ•°æ®ï¼‰
                const channels = (node.channels || []).map((ch, index) => {
                    // æ ¹æ®é€šé“ç±»å‹ç¡®å®šé¢œè‰²
                    let color = "primary";
                    
                    if (ch.type === "DC") {
                        color = ch.value < 0 ? "danger" : "primary";
                    } else if (ch.type === "Current") {
                        color = "info";
                    } else if (ch.type === "Leakage") {
                        color = "warning";
                    } else if (ch.type === "ISO") {
                        color = "success";
                    } else if (ch.type === "Temp") {
                        color = "danger";
                    }
                    
                    // ç¡®å®šèŒƒå›´ï¼ˆåŸºäºé€šé“ç±»å‹å’Œå•ä½ï¼‰
                    let defaultRange = [0, 1000];
                    if (ch.unit === "V") defaultRange = ch.value < 0 ? [-800, 0] : [0, 800];
                    else if (ch.unit === "A") defaultRange = [0, 60];
                    else if (ch.unit === "mA") defaultRange = [0, 50];
                    else if (ch.unit === "MÎ©") defaultRange = [0, 100];
                    else if (ch.unit === "Â°C") defaultRange = [0, 100];
                    
                    const currentValue = ch.value !== undefined ? ch.value : 0;
                    
                    return {
                        id: ch.id !== undefined ? ch.id : index,
                        label: ch.label || `é€šé“${index + 1}`,
                        unit: ch.unit || "",
                        type: ch.type || "DC",
                        range: ch.range || defaultRange,
                        color: color,
                        currentValue: currentValue,  // å½“å‰ç¬æ—¶å€¼ï¼ˆä»åç«¯æ¥æ”¶ï¼‰
                        waveform: ch.waveform || [],  // æ³¢å½¢æ•°ç»„ï¼ˆä»åç«¯æ¥æ”¶ï¼Œ120ä¸ªé‡‡æ ·ç‚¹ï¼‰
                        fft_spectrum: ch.fft_spectrum || []  // FFTé¢‘è°±æ•°ç»„ï¼ˆä»åç«¯æ¥æ”¶ï¼Œ30ä¸ªé¢‘ç‡binï¼‰
                    };
                });
                
                newConfigs[nodeId] = {
                    status: node.status || "online",
                    fault_code: node.fault_code || "E00",  // ä¿å­˜æ•…éšœä»£ç 
                    channels: channels
                };
            });
            
            // æ£€æŸ¥é…ç½®æ˜¯å¦å‘ç”Ÿå˜åŒ–
            const configChanged = JSON.stringify(NODE_CONFIGS) !== JSON.stringify(newConfigs);
            
            // ========== æ£€æµ‹æ•…éšœçŠ¶æ€å˜åŒ–ï¼ˆè§¦å‘å¼¹çª—å’Œæ¶ˆæ¯ï¼‰==========
            const faultStateChanges = {};
            Object.keys(newConfigs).forEach(nodeId => {
                const oldNode = NODE_CONFIGS[nodeId];
                const newNode = newConfigs[nodeId];
                
                if (oldNode) {
                    const oldFaultCode = oldNode.fault_code || 'E00';
                    const newFaultCode = newNode.fault_code || 'E00';
                    
                    // æ£€æµ‹ä»æ­£å¸¸åˆ°æ•…éšœçš„çŠ¶æ€å˜åŒ–
                    if (oldFaultCode === 'E00' && newFaultCode !== 'E00') {
                        faultStateChanges[nodeId] = {
                            from: oldFaultCode,
                            to: newFaultCode,
                            status: newNode.status
                        };
                    }
                }
            });
            
            if (configChanged) {
                // æ›´æ–°é…ç½®
                NODE_CONFIGS = newConfigs;
            
            // æ›´æ–°è¾¹ç¼˜èŠ‚ç‚¹åˆ—è¡¨æ˜¾ç¤º
            renderNodeList();
            
                // ========== æ•…éšœçŠ¶æ€å˜åŒ–æ£€æµ‹ï¼ˆä»…è®°å½•æ—¥å¿—ï¼Œä¸è§¦å‘é€šçŸ¥ï¼‰==========
                // ä¿®å¤ï¼šç§»é™¤é‡å¤é€šçŸ¥é€»è¾‘ï¼Œå› ä¸ºå…¨å±€ç›‘æ§ï¼ˆbase.htmlï¼‰å·²ç»ç»Ÿä¸€å¤„ç†æ•…éšœé€šçŸ¥
                // è¿™é‡Œåªè®°å½•æ—¥å¿—ï¼Œé¿å…åŒé‡å¼¹çª—
                Object.keys(faultStateChanges).forEach(nodeId => {
                    const change = faultStateChanges[nodeId];
                    const faultTypeName = getFaultTypeName(change.to);
                    
                    // åªè®°å½•æ—¥å¿—ï¼Œä¸è§¦å‘ä»»ä½•é€šçŸ¥ï¼ˆå…¨å±€ç›‘æ§å·²å¤„ç†ï¼‰
                    console.log(`[Monitoré¡µé¢] è¾¹ç¼˜èŠ‚ç‚¹ ${nodeId} æ•…éšœçŠ¶æ€å˜åŒ–: ${change.from} -> ${change.to} (${faultTypeName})`);
                    // æ³¨æ„ï¼šä¸å†è°ƒç”¨ showToastï¼Œå› ä¸ºå…¨å±€ç›‘æ§çš„ publishSystemEvent å·²ç»å¤„ç†äº†é€šçŸ¥
                });
                
                // å¦‚æœæœ‰å¾…é€‰æ‹©çš„è¾¹ç¼˜èŠ‚ç‚¹ï¼ˆä»URLå‚æ•°ï¼‰ï¼Œä¼˜å…ˆé€‰æ‹©å®ƒ
                if (pendingNodeSelection) {
                    trySelectPendingNode();
                }
                // å¦‚æœå½“å‰é€‰ä¸­çš„è¾¹ç¼˜èŠ‚ç‚¹å·²ä¸å­˜åœ¨ï¼Œé€‰æ‹©ç¬¬ä¸€ä¸ªå¯ç”¨è¾¹ç¼˜èŠ‚ç‚¹
                else if (currentNodeId && !NODE_CONFIGS[currentNodeId]) {
                    const firstNode = Object.keys(NODE_CONFIGS)[0];
                    if (firstNode) {
                        selectNode(firstNode);
                    } else {
                        currentNodeId = null;
                        renderChannelCards();
                    }
                } else if (currentNodeId) {
                    // åˆ·æ–°å½“å‰è¾¹ç¼˜èŠ‚ç‚¹çš„æ˜¾ç¤º
                renderChannelCards();
                updateCharts();
                }
                
                // å¤„ç†è‡ªåŠ¨èšç„¦é€»è¾‘ï¼ˆä¼˜å…ˆäºé¦–æ¬¡åŠ è½½ï¼‰
                if (!autoFocusHandled && Object.keys(NODE_CONFIGS).length > 0) {
                    handleAutoFocus();
                }
                
                // é¦–æ¬¡åŠ è½½æ—¶è‡ªåŠ¨é€‰æ‹©ç¬¬ä¸€ä¸ªè¾¹ç¼˜èŠ‚ç‚¹ï¼ˆå¦‚æœæ²¡æœ‰è‡ªåŠ¨èšç„¦ï¼‰
                if (isFirstLoad && Object.keys(NODE_CONFIGS).length > 0 && !autoFocusHandled) {
                    const firstNode = Object.keys(NODE_CONFIGS)[0];
                    if (firstNode && !currentNodeId) {
                        selectNode(firstNode);
                        isFirstLoad = false;
                    }
                }
            }
            
            // è¾…åŠ©å‡½æ•°ï¼šè·å–æ•…éšœç±»å‹åç§°
            function getFaultTypeName(faultCode) {
                const faultNames = {
                    'E01': 'äº¤æµçªœå…¥',
                    'E02': 'ç»ç¼˜æ•…éšœ',
                    'E03': 'ç›´æµæ¯çº¿ç”µå®¹è€åŒ–',
                    'E04': 'å˜æµå™¨IGBTå¼€è·¯',
                    'E05': 'ç›´æµæ¯çº¿æ¥åœ°æ•…éšœ'
                };
                return faultNames[faultCode] || `æ•…éšœ ${faultCode}`;
            }
            
        } catch (error) {
            console.error('[fetchActiveNodes] è·å–è¾¹ç¼˜èŠ‚ç‚¹åˆ—è¡¨æ—¶å‡ºé”™:', error);
            // å³ä½¿å‡ºé”™ä¹Ÿç»§ç»­è½®è¯¢ï¼Œä¸ä¸­æ–­
            // å¦‚æœè·å–å¤±è´¥ï¼Œæ˜¾ç¤ºç­‰å¾…æç¤º
            if (Object.keys(NODE_CONFIGS).length === 0) {
            renderNodeList();
            }
        }
    }

    // ========== å¤„ç†è‡ªåŠ¨èšç„¦é€»è¾‘ ==========
    function handleAutoFocus() {
        if (autoFocusHandled) return;  // åªå¤„ç†ä¸€æ¬¡
        
        const focusType = getQueryParam('focus');
        let targetNodeId = null;
        
        if (focusType === 'fault') {
            // æŸ¥æ‰¾ç¬¬ä¸€ä¸ªæ•…éšœè¾¹ç¼˜èŠ‚ç‚¹
            const faultyNode = Object.keys(NODE_CONFIGS).find(nodeId => {
                const node = NODE_CONFIGS[nodeId];
                return node && (node.status === 'fault' || node.status === 'faulty' || (node.fault_code && node.fault_code !== 'E00'));
            });
            if (faultyNode) {
                targetNodeId = faultyNode;
            }
        } else if (getQueryParam('node_id')) {
            // æ”¯æŒç›´æ¥é“¾æ¥: /monitor?node_id=STM32_Node_004
            targetNodeId = getQueryParam('node_id');
        }
        
        // å¦‚æœæ‰¾åˆ°äº†ç›®æ ‡è¾¹ç¼˜èŠ‚ç‚¹ï¼Œåˆ™è‡ªåŠ¨é€‰æ‹©
        if (targetNodeId) {
            selectNode(targetNodeId);
            autoFocusHandled = true;
            
            // æ¸…é™¤URLå‚æ•°ï¼Œé˜²æ­¢åˆ·æ–°æ—¶é‡å¤é€‰æ‹©
            window.history.replaceState({}, document.title, '/monitor');
            
            // æ»šåŠ¨åˆ°è¾¹ç¼˜èŠ‚ç‚¹åœ¨ä¾§è¾¹æ ä¸­çš„ä½ç½®ï¼ˆåªåœ¨é¦–æ¬¡è‡ªåŠ¨èšç„¦æ—¶æ‰§è¡Œï¼Œé¿å…é‡å¤æ»šåŠ¨å¯¼è‡´è·³åŠ¨ï¼‰
            if (!autoFocusHandled) {
                setTimeout(() => {
                    const el = document.querySelector(`[data-node-id="${targetNodeId}"]`);
                    if (el) {
                        el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        // é«˜äº®æ˜¾ç¤ºé€‰ä¸­çš„è¾¹ç¼˜èŠ‚ç‚¹ï¼ˆé€šè¿‡activeç±»ï¼‰
                        const nodeListItems = document.querySelectorAll('#nodeList .list-group-item');
                        nodeListItems.forEach(item => item.classList.remove('active'));
                        el.classList.add('active');
                    }
                }, 500);
            }
            
            console.log(`âœ… å·²è‡ªåŠ¨èšç„¦åˆ°è¾¹ç¼˜èŠ‚ç‚¹: ${targetNodeId}`);
        } else if (focusType && !targetNodeId) {
            // å¦‚æœæŒ‡å®šäº†focusä½†æ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„è¾¹ç¼˜èŠ‚ç‚¹ï¼Œæ ‡è®°ä¸ºå·²å¤„ç†ï¼Œé¿å…é‡å¤å°è¯•
            autoFocusHandled = true;
            window.history.replaceState({}, document.title, '/monitor');
            console.log(`âš ï¸ æœªæ‰¾åˆ°åŒ¹é…çš„è¾¹ç¼˜èŠ‚ç‚¹ (focus: ${focusType})`);
        }
    }

    // ========== æ¸²æŸ“è¾¹ç¼˜èŠ‚ç‚¹åˆ—è¡¨ (å·¦ä¾§è¾¹æ ) - ç¨³å®šå°±åœ°æ›´æ–°ç‰ˆæœ¬ ==========
    let nodeListFirstRender = true;  // æ ‡è®°æ˜¯å¦ä¸ºé¦–æ¬¡æ¸²æŸ“ï¼ˆç”¨äºæ§åˆ¶è‡ªåŠ¨æ»šåŠ¨ï¼‰

    // å®‰å…¨ï¼šé¿å…æŠŠ node_id ç­‰å­—æ®µç›´æ¥æ‹¼è¿› innerHTML é€ æˆ XSS/é€‰æ‹©å™¨æ³¨å…¥
    function escapeHtml(s) {
        const str = String(s ?? '');
        return str
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');
    }

    function sanitizeDomId(raw) {
        // id åªèƒ½ä½¿ç”¨å®‰å…¨å­—ç¬¦ï¼Œé¿å… querySelector / CSS é€‰æ‹©å™¨å¼‚å¸¸
        return String(raw ?? '').replace(/[^A-Za-z0-9_-]/g, '_');
    }

    function badgeDomId(nodeId) {
        return `badge-${sanitizeDomId(nodeId)}`;
    }

    function findNodeListItem(nodeListEl, nodeId) {
        if (!nodeListEl) return null;
        for (const child of Array.from(nodeListEl.children)) {
            if (child && child.getAttribute && child.getAttribute('data-node-id') === nodeId) {
                return child;
            }
        }
        return null;
    }
    
    function renderNodeList() {
        const nodeList = document.getElementById('nodeList');
        if (!nodeList) return;
        
        // è·å–æ‰€æœ‰è¾¹ç¼˜èŠ‚ç‚¹å¹¶è½¬æ¢ä¸ºæ•°ç»„ï¼ŒæŒ‰ node_id å­—æ¯é¡ºåºæ’åºï¼ˆç¨³å®šæ’åºï¼‰
        const nodeArray = Object.keys(NODE_CONFIGS)
            .map(nodeId => ({
                node_id: nodeId,
                ...NODE_CONFIGS[nodeId]
            }))
            .sort((a, b) => a.node_id.localeCompare(b.node_id));  // å›ºå®šæ’åºï¼Œé˜²æ­¢è·³åŠ¨
        
        // å¦‚æœæ²¡æœ‰è¾¹ç¼˜èŠ‚ç‚¹ï¼Œæ˜¾ç¤ºç­‰å¾…æç¤º
        if (nodeArray.length === 0) {
            // åªåœ¨é¦–æ¬¡æ¸²æŸ“æˆ–è¾¹ç¼˜èŠ‚ç‚¹åˆ—è¡¨ä¸ºç©ºæ—¶æ¸…ç©º
            if (nodeListFirstRender || nodeList.children.length === 0) {
                nodeList.innerHTML = `
                    <div class="text-center text-muted py-5">
                        <div class="spinner-border spinner-border-sm mb-2" role="status">
                            <span class="visually-hidden">åŠ è½½ä¸­...</span>
                        </div>
                        <div>ç­‰å¾…è¾¹ç¼˜èŠ‚ç‚¹è¿æ¥...</div>
                        <small class="text-muted d-block mt-2">è¯·ç¡®ä¿æ¨¡æ‹Ÿå™¨æ­£åœ¨è¿è¡Œ</small>
                    </div>
                `;
            }
            nodeListFirstRender = false;
            return;
        }

        // æ¸…é™¤ç­‰å¾…æç¤ºï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        const waitingMsg = nodeList.querySelector('.text-center.text-muted');
        if (waitingMsg) {
            waitingMsg.remove();
        }
        
        // è·å–å½“å‰å­˜åœ¨çš„æ‰€æœ‰è¾¹ç¼˜èŠ‚ç‚¹å…ƒç´ ID
        const existingNodeIds = new Set();
        Array.from(nodeList.children).forEach(child => {
            const nodeId = child.getAttribute('data-node-id');
            if (nodeId) {
                existingNodeIds.add(nodeId);
            }
        });
        
        // éå†æ’åºåçš„è¾¹ç¼˜èŠ‚ç‚¹æ•°ç»„ï¼Œè¿›è¡Œå·®å¼‚æ›´æ–°
        nodeArray.forEach((node, index) => {
            const nodeId = node.node_id;
            const status = node.status || 'offline';
            const faultCode = node.fault_code || 'E00';
            const isActive = nodeId === currentNodeId;
            // å…³é”®ï¼šä»¥ fault_code ä¸ºå‡†åˆ¤æ–­â€œæ˜¯å¦æ•…éšœâ€ï¼Œé¿å…å‡ºç°åœ¨çº¿/æ­£å¸¸æ¥å›è·³
            // åç«¯åœ¨ node_status_update ä¸­å¯èƒ½ä¸€ç›´ä¼  status=onlineï¼Œä½† fault_code ä¼šå˜åŒ–ï¼ˆE00/E01...ï¼‰
            const isFault = (faultCode && faultCode !== 'E00') || status === 'fault' || status === 'faulty';
            
            // ç¡®å®šçŠ¶æ€å¾½ç« æ ·å¼ï¼ˆå•ä¸€å¾½ç« ï¼šç¦»çº¿ / æ­£å¸¸ / æ•…éšœç ï¼‰
            let badgeClass, badgeText, badgeIcon;
            if (isFault) {
                badgeClass = 'bg-danger';
                badgeText = faultCode;
                badgeIcon = 'âš ';
            } else if (status === 'online') {
                badgeClass = 'bg-success';
                // ç»Ÿä¸€æ˜¾ç¤ºâ€œæ­£å¸¸â€ï¼Œé¿å…â€œåœ¨çº¿/æ­£å¸¸â€æ¥å›åˆ‡æ¢é€ æˆè§‚æ„Ÿè·³åŠ¨
                badgeText = 'æ­£å¸¸';
                badgeIcon = 'â—';
                } else {
                badgeClass = 'bg-secondary';
                badgeText = 'ç¦»çº¿';
                badgeIcon = 'â—‹';
            }
            
            // æŸ¥æ‰¾ç°æœ‰å…ƒç´ 
            let listItem = findNodeListItem(nodeList, nodeId);
            
            if (!listItem) {
                // A. åˆ›å»ºæ–°å…ƒç´ ï¼ˆé¦–æ¬¡å‡ºç°ï¼‰
                listItem = document.createElement('div');
                listItem.setAttribute('data-node-id', nodeId);
                listItem.className = 'list-group-item list-group-item-action';
                listItem.style.cursor = 'pointer';
                listItem.onclick = () => selectNode(nodeId);

                const bid = badgeDomId(nodeId);
                
                listItem.innerHTML = `
                    <div class="d-flex justify-content-between align-items-center">
                        <div class="flex-grow-1 d-flex align-items-center">
                            <div class="fw-bold">${escapeHtml(nodeId)}</div>
                        </div>
                        <span id="${bid}" class="badge rounded-pill ${badgeClass}">
                            ${badgeIcon} ${badgeText}
                        </span>
                </div>
            `;
                
                // æ’å…¥åˆ°æ­£ç¡®çš„ä½ç½®ï¼ˆä¿æŒæ’åºï¼‰
                // æ‰¾åˆ°åº”è¯¥æ’å…¥çš„ä½ç½®ï¼ˆæŒ‰å­—æ¯é¡ºåºï¼‰
                let insertBefore = null;
                for (let i = index + 1; i < nodeArray.length; i++) {
                    const nextNodeId = nodeArray[i].node_id;
                    const nextElement = findNodeListItem(nodeList, nextNodeId);
                    if (nextElement) {
                        insertBefore = nextElement;
                        break;
                    }
                }
                
                if (insertBefore) {
                    nodeList.insertBefore(listItem, insertBefore);
            } else {
                    nodeList.appendChild(listItem);
                }
            } else {
                // B. æ›´æ–°ç°æœ‰å…ƒç´ ï¼ˆå°±åœ°æ›´æ–°ï¼Œåªä¿®æ”¹å˜åŒ–çš„éƒ¨åˆ†ï¼‰
                const badge = listItem.querySelector(`#${badgeDomId(nodeId)}`);
                
                if (badge) {
                    // è·å–å½“å‰badgeçš„classå’Œtext
                    const currentBadgeClass = badge.classList.contains('bg-danger') ? 'bg-danger' :
                                             badge.classList.contains('bg-success') ? 'bg-success' : 'bg-secondary';
                    const currentBadgeText = badge.textContent.trim();
                    const targetBadgeText = `${badgeIcon} ${badgeText}`;
                    
                    // åªåœ¨çŠ¶æ€å˜åŒ–æ—¶æ›´æ–°badgeï¼ˆé¿å…ä¸å¿…è¦çš„DOMæ“ä½œï¼‰
                    if (currentBadgeClass !== badgeClass || currentBadgeText !== targetBadgeText) {
                        // æ›´æ–°badge class
                        badge.classList.remove('bg-danger', 'bg-success', 'bg-secondary');
                        badge.classList.add(badgeClass);
                        // æ›´æ–°badge text
                        badge.textContent = targetBadgeText;
                    }
                }
            }
            
            // æ›´æ–°é€‰ä¸­çŠ¶æ€å’Œæ ·å¼ï¼ˆåªåœ¨å˜åŒ–æ—¶æ›´æ–°ï¼‰
            const shouldBeActive = isActive;
            const isCurrentlyActive = listItem.classList.contains('border-start') && 
                                     listItem.classList.contains('border-primary');
            
            if (shouldBeActive !== isCurrentlyActive) {
                if (shouldBeActive) {
                    listItem.classList.add('border-start', 'border-4', 'border-primary', 'bg-light');
                } else {
                    listItem.classList.remove('border-start', 'border-4', 'border-primary', 'bg-light');
                }
            }
            
            // æ›´æ–°æ•…éšœè„‰å†²åŠ¨ç”»ï¼ˆåªåœ¨å˜åŒ–æ—¶æ›´æ–°ï¼‰
            const shouldHavePulse = isFault;
            const hasPulse = listItem.classList.contains('fault-pulse');
            
            if (shouldHavePulse !== hasPulse) {
                if (shouldHavePulse) {
                    listItem.classList.add('fault-pulse');
                } else {
                    listItem.classList.remove('fault-pulse');
                }
            }
            
            // ä»existingNodeIdsä¸­ç§»é™¤ï¼Œæ ‡è®°ä¸ºå·²å¤„ç†
            existingNodeIds.delete(nodeId);
        });
        
        // C. ç§»é™¤å·²æ–­å¼€çš„è¾¹ç¼˜èŠ‚ç‚¹ï¼ˆä¸å†å­˜åœ¨äºNODE_CONFIGSä¸­ï¼‰
        existingNodeIds.forEach(removedNodeId => {
            const removedElement = findNodeListItem(nodeList, removedNodeId);
            if (removedElement) {
                removedElement.remove();
            }
        });
        
        // æ ‡è®°é¦–æ¬¡æ¸²æŸ“å®Œæˆ
        if (nodeListFirstRender) {
            nodeListFirstRender = false;
        }
    }

    // ========== æ¸²æŸ“é€šé“å¡ç‰‡ (é¡¶éƒ¨æ°´å¹³æ’åˆ—) ==========
    // ç¼“å­˜ä¸Šæ¬¡çš„é€šé“å¡ç‰‡çŠ¶æ€ï¼Œç”¨äºé€‰æ‹©æ€§æ›´æ–°
    let lastChannelCardStates = {};
    
    function renderChannelCards() {
        // å…¼å®¹ï¼šé¡µé¢é¡¶éƒ¨å¯èƒ½ä½¿ç”¨çš„æ˜¯å›ºå®š4å¡ç‰‡å¸ƒå±€ï¼ˆcard-voltageç­‰ï¼‰ï¼Œè€Œä¸æ˜¯ channelCardsRow å®¹å™¨ã€‚
        // è‹¥å®¹å™¨ä¸å­˜åœ¨ï¼Œç›´æ¥è·³è¿‡ï¼Œé¿å…æŠ¥é”™å¯¼è‡´æ•´ä¸ªå‰ç«¯æ›´æ–°å¾ªç¯ä¸­æ–­ï¼ˆä½ çœ‹åˆ°çš„ innerHTML of nullï¼‰ã€‚
        const channelCardsRowEl = document.getElementById('channelCardsRow');
        if (!channelCardsRowEl) {
            return;
        }

        if (!currentNodeId) {
            channelCardsRowEl.innerHTML = 
                '<div class="col-12 text-center text-muted py-5">è¯·å…ˆé€‰æ‹©è¾¹ç¼˜èŠ‚ç‚¹</div>';
            return;
        }
        
        const node = NODE_CONFIGS[currentNodeId];
        if (!node) return;
        
        const container = channelCardsRowEl;
        const currentStates = {};
        // å®‰å…¨ï¼šcurrentNodeId å¯èƒ½æ¥è‡ªå¤–éƒ¨æ•°æ®ï¼Œç”¨äº DOM id æ—¶å¿…é¡»å‡€åŒ–
        const safeNodeIdForDom = sanitizeDomId(currentNodeId);
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦å®Œå…¨é‡æ–°æ¸²æŸ“ï¼ˆè¾¹ç¼˜èŠ‚ç‚¹å˜åŒ–æˆ–é¦–æ¬¡æ¸²æŸ“ï¼‰
        const needsFullRender = !lastChannelCardStates[currentNodeId] || 
                                 Object.keys(lastChannelCardStates[currentNodeId]).length !== node.channels.length;
        
        if (needsFullRender) {
            // å®Œå…¨é‡æ–°æ¸²æŸ“
        const html = node.channels.map((channel, index) => {
            const channelData = nodeData[currentNodeId]?.[channel.id];
                const currentValue = channelData?.currentValue || channel.currentValue || 0;
            const displayValue = formatValue(currentValue, channel.unit);
            const isSelected = index === currentChannelIndex;

            // å®‰å…¨ï¼šé¢œè‰²ä»…å…è®¸ Bootstrap è¯­ä¹‰è‰²ï¼Œé¿å…æŠŠä»»æ„å­—ç¬¦ä¸²æ‹¼è¿› CSS var
            const allowedColors = new Set(['primary','danger','info','warning','success','secondary','dark','light']);
            const safeColor = allowedColors.has(String(channel.color || '').trim()) ? String(channel.color).trim() : 'primary';
            const safeLabel = escapeHtml(channel.label || channel.name || `é€šé“${index + 1}`);
            const gaugeDomId = `gauge-${safeNodeIdForDom}-${index}`;
            
            // é€‰ä¸­çŠ¶æ€æ ·å¼
            const selectedClass = isSelected ? 'border-primary border-2 shadow-sm' : '';
            const selectedBg = isSelected ? 'bg-light' : '';
                
                currentStates[index] = { value: currentValue, isSelected };
            
            return `
                <div class="col-md-3 mb-3">
                    <div class="card channel-card ${selectedClass} ${selectedBg}" 
                         onclick="selectChannel(${index})"
                         style="cursor: pointer; border-top: 4px solid var(--bs-${safeColor});">
                            <div class="card-body text-center p-2">
                                <div class="text-muted small mb-1">${safeLabel}</div>
                                <div id="${gaugeDomId}" style="height: 160px; width: 100%;"></div>
                        </div>
                    </div>
                </div>
            `;
        }).join('');
        
        container.innerHTML = html;
            lastChannelCardStates[currentNodeId] = currentStates;
            
            // åˆå§‹åŒ–æ‰€æœ‰Gaugeå›¾è¡¨ï¼ˆå»¶è¿Ÿæ‰§è¡Œï¼Œç¡®ä¿DOMå·²æ¸²æŸ“ï¼‰
            setTimeout(() => {
                node.channels.forEach((channel, index) => {
                    const gaugeId = `gauge-${safeNodeIdForDom}-${index}`;
                    // ç¡®ä¿é€šé“æ•°æ®åŒ…å« currentValueï¼ˆå¦‚æœåªæœ‰ valueï¼Œåˆ™è½¬æ¢ï¼‰
                    const channelData = nodeData[currentNodeId]?.[channel.id];
                    if (channelData) {
                        if (channelData.currentValue === undefined && channelData.value !== undefined) {
                            channelData.currentValue = channelData.value;
                        }
                        channel.currentValue = channelData.currentValue;
                    } else if (channel.value !== undefined && channel.currentValue === undefined) {
                        channel.currentValue = channel.value;
                    }
                    initOrUpdateGauge(gaugeId, channel, currentNodeId, index);
                });
            }, 200);
        } else {
            // å¢é‡æ›´æ–°ï¼šåªæ›´æ–°å˜åŒ–çš„å€¼
            node.channels.forEach((channel, index) => {
                const channelData = nodeData[currentNodeId]?.[channel.id];
                const currentValue = channelData?.currentValue || channel.currentValue || 0;
                const displayValue = formatValue(currentValue, channel.unit);
                const isSelected = index === currentChannelIndex;
                
                const lastState = lastChannelCardStates[currentNodeId][index];
                const valueChanged = !lastState || lastState.value !== currentValue;
                const selectionChanged = !lastState || lastState.isSelected !== isSelected;
                
                // åªåœ¨å€¼æˆ–é€‰ä¸­çŠ¶æ€å˜åŒ–æ—¶æ›´æ–°DOM
                if (valueChanged || selectionChanged) {
                    const valueElement = document.getElementById(`channel-card-value-${currentNodeId}-${index}`);
                    if (valueElement && valueChanged) {
                        valueElement.textContent = displayValue;
                    }
                    
                    // æ›´æ–°é€‰ä¸­çŠ¶æ€
                    if (selectionChanged) {
                        const cardElement = valueElement?.closest('.card');
                        if (cardElement) {
                            if (isSelected) {
                                cardElement.classList.add('border-primary', 'border-2', 'shadow-sm', 'bg-light');
                                // æ·»åŠ é€‰ä¸­æ ‡è®°
                                const cardBody = cardElement.querySelector('.card-body');
                                if (cardBody && !cardBody.querySelector('.text-primary')) {
                                    const selectedDiv = document.createElement('div');
                                    selectedDiv.className = 'mt-2';
                                    selectedDiv.innerHTML = '<small class="text-primary"><i class="bi bi-check-circle"></i> å·²é€‰ä¸­</small>';
                                    cardBody.appendChild(selectedDiv);
                                }
                            } else {
                                cardElement.classList.remove('border-primary', 'border-2', 'shadow-sm', 'bg-light');
                                // ç§»é™¤é€‰ä¸­æ ‡è®°
                                const selectedDiv = cardElement.querySelector('.text-primary')?.closest('.mt-2');
                                if (selectedDiv) selectedDiv.remove();
                            }
                        }
                    }
                    
                    currentStates[index] = { value: currentValue, isSelected };
                } else {
                    currentStates[index] = lastState;
                }
            });
            
            lastChannelCardStates[currentNodeId] = currentStates;
        }
    }

    // ========== é€‰æ‹©è¾¹ç¼˜èŠ‚ç‚¹ï¼ˆä¼˜åŒ–ç‰ˆï¼šæ·»åŠ è®¢é˜…ç®¡ç†ï¼‰ ==========
    function selectNode(nodeId) {
        // å¦‚æœé€‰æ‹©çš„æ˜¯åŒä¸€ä¸ªèŠ‚ç‚¹ï¼Œç›´æ¥è¿”å›
        if (currentNodeId === nodeId) {
            return;
        }
        
        // å–æ¶ˆè®¢é˜…ä¹‹å‰çš„èŠ‚ç‚¹ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        if (currentNodeId && socket && socket.connected) {
            socket.emit('unsubscribe_node', { node_id: currentNodeId });
            console.log(`ğŸ“¡ å–æ¶ˆè®¢é˜…èŠ‚ç‚¹: ${currentNodeId}`);
        }
        
        // æ›´æ–°å½“å‰èŠ‚ç‚¹ID
        currentNodeId = nodeId;
        currentChannelIndex = 0;
        
        // è®¢é˜…æ–°èŠ‚ç‚¹çš„å®Œæ•´æ•°æ®
        if (socket && socket.connected) {
            socket.emit('subscribe_node', { node_id: nodeId });
            console.log(`ğŸ“¡ è®¢é˜…èŠ‚ç‚¹: ${nodeId}`);
        }
        
        // åº”ç”¨æ•…éšœæ¨¡å¼è§†è§‰æ•ˆæœ
        const node = NODE_CONFIGS[nodeId];
        const status = node && node.status ? node.status : 'offline';
        applyFaultModeEffects(status);
        
        // æ›´æ–°è¾¹ç¼˜èŠ‚ç‚¹åˆ—è¡¨ï¼ˆé«˜äº®å½“å‰é€‰ä¸­ï¼‰- ä½¿ç”¨ç¨³å®šçš„å°±åœ°æ›´æ–°ï¼Œä¸ä¼šå¯¼è‡´è·³åŠ¨
        renderNodeList();
        
        // æ›´æ–°é€šé“å¡ç‰‡
        renderChannelCards();
        
        // æ›´æ–°å¡ç‰‡é«˜äº®ï¼ˆé»˜è®¤é€‰ä¸­ç¬¬ä¸€ä¸ªé€šé“/voltageï¼‰
        currentSource = 'voltage';
        selectSource('voltage');
        
        // æ›´æ–°å›¾è¡¨
        updateCharts();
        
        // æ›´æ–°æ€§èƒ½ç›‘æ§é¢æ¿
        updatePerfPanel();
    }

    // ========== é€‰æ‹©é€šé“ï¼ˆä¿ç•™å…¼å®¹æ€§ï¼‰==========
    function selectChannel(index) {
        currentChannelIndex = index;
        // Map index to source
        const indexToSource = {0: 'voltage', 1: 'voltage_neg', 2: 'current', 3: 'leakage'};
        const source = indexToSource[index] || 'voltage';
        selectSource(source);
    }
    
    // ========== æ•…éšœæ—¥å¿—è¾…åŠ©å‡½æ•° ==========
    // timeStr: å»ºè®®ä¼ å…¥ "YYYY-MM-DD HH:MM:SS"ï¼ˆä¾¿äºè·³è½¬å¿«ç…§äº‹ä»¶ï¼‰
    function addLogEntry(nodeId, faultCode, timeStr, status = 'pending', logId = null) {
        const tbody = document.getElementById('fault-log-body');
        if (!tbody) {
            console.warn('[addLogEntry] æ‰¾ä¸åˆ°æ•…éšœæ—¥å¿—è¡¨ä½“å…ƒç´ ');
            return;
        }

        // åªè®°å½•çœŸå®æ•…éšœï¼ˆE01-E05ï¼‰ï¼ŒE00 ä¸è¿›å…¥â€œç³»ç»Ÿæ•…éšœæ—¥å¿—â€
        if (!faultCode || faultCode === 'E00') {
            return;
        }

        const normStatus = normalizeFaultStatus(status);
        const dedupeKey = `${timeStr}|${nodeId}|${faultCode}`;
        const idKey = (logId !== null && logId !== undefined) ? `id:${logId}` : null;

        // å…³é”®ä¿®å¤ï¼šå¦‚æœè½®è¯¢æ‹¿åˆ°äº† idï¼Œè€Œä¹‹å‰ WebSocket/å®æ—¶é“¾è·¯å†™è¿‡â€œæ—  id ä¸´æ—¶è®°å½•â€ï¼Œè¿™é‡Œè¦åˆå¹¶åˆ°åŒä¸€æ¡
        if (idKey && faultLogMap.has(dedupeKey)) {
            const old = faultLogMap.get(dedupeKey);
            if (old && (old.id === null || old.id === undefined)) {
                faultLogMap.delete(dedupeKey);
            }
        }

        const key = idKey || dedupeKey;
        const prev = faultLogMap.get(key);
        const next = {
            id: (logId !== null && logId !== undefined) ? logId : (prev ? prev.id : null),
            nodeId,
            faultCode,
            timeStr,
            status: normStatus,
            tsMs: parseBeijingTimeToMs(timeStr)
        };

        // è‹¥å·²å­˜åœ¨ï¼Œå…è®¸çŠ¶æ€æ›´æ–°ï¼›æ—¶é—´å–æ›´æ–°åå¯è§£æçš„ï¼ˆé€šå¸¸ä¸€è‡´ï¼‰
        faultLogMap.set(key, next);

        // ç»Ÿä¸€æ’åºæ¸²æŸ“ï¼ˆæœªå¤„ç†/å¤„ç†ä¸­/å·²å¤„ç† + æ—¶é—´ï¼‰
        renderFaultLogTable(50);
    }

    // ========== æ•…éšœæ—¥å¿—ï¼šç©ºçŠ¶æ€æç¤º ==========
    function renderFaultLogEmptyState() {
        const tbody = document.getElementById('fault-log-body');
        if (!tbody) return;
        if (tbody.children.length > 0) return;

        const row = document.createElement('tr');
        row.setAttribute('data-empty', '1');
        row.innerHTML = `
            <td colspan="4" class="text-center text-muted py-3">
                æš‚æ— æ•…éšœè®°å½•ï¼ˆå½“æ£€æµ‹åˆ°æ•…éšœ/æ¢å¤æ—¶ä¼šè‡ªåŠ¨è¿½åŠ ï¼‰
            </td>
        `;
        tbody.appendChild(row);
    }

    // ========== æ•…éšœæ—¥å¿—ï¼šå†å²å›å¡«ï¼ˆä»åç«¯æ‹‰å–æœ€è¿‘å·¥å•/æ•…éšœè®°å½•ï¼‰==========
    async function loadFaultLogHistory(limit = 50) {
        try {
            const resp = await fetch('/api/faults');
            if (!resp.ok) {
                console.warn(`[loadFaultLogHistory] HTTPé”™è¯¯: ${resp.status} ${resp.statusText}`);
                renderFaultLogEmptyState();
                return;
            }
            const result = await resp.json();
            const faults = Array.isArray(result.faults) ? result.faults : [];

            // ä»…å±•ç¤ºâ€œçœŸå®æ•…éšœâ€ï¼ˆE01-E05ï¼‰ï¼›E00 ä¸å†™å…¥æ•…éšœæ—¥å¿—
            const faultOnly = faults.filter(f => (f.fault_code || 'E00') !== 'E00');

            // åç«¯æŒ‰æ—¶é—´å€’åºè¿”å›ï¼Œè¿™é‡Œåè½¬åæŒ‰â€œæ—§->æ–°â€å†™å…¥ï¼Œç¡®ä¿æœ€æ–°åœ¨é¡¶éƒ¨
            const ordered = faultOnly.slice(0, limit).reverse();
            for (const f of ordered) {
                const nodeId = f.device_id || 'N/A';
                const code = f.fault_code || 'E00';
                const st = f.status || 'pending';
                const logId = (f.id !== undefined && f.id !== null) ? f.id : null;

                // ä¼˜å…ˆä½¿ç”¨åç«¯æä¾›çš„å±•ç¤ºå­—ç¬¦ä¸²ï¼›å¦åˆ™è§£æ ISO æ—¶é—´
                let timeStr = f.time;
                if (!timeStr && f.fault_time) {
                    const dt = new Date(f.fault_time);
                    timeStr = isNaN(dt.getTime()) ? String(f.fault_time) : formatDateTimeForSnapshot(dt);
                }
                if (!timeStr) {
                    timeStr = formatDateTimeForSnapshot(new Date());
                }

                addLogEntry(nodeId, code, timeStr, st, logId);
            }

            faultLogHistoryLoaded = true;
            renderFaultLogTable(50);
        } catch (e) {
            console.warn('[loadFaultLogHistory] æ‹‰å–æ•…éšœæ—¥å¿—å¤±è´¥:', e);
            renderFaultLogEmptyState();
        }
    }

    // ========== æ•…éšœæ—¥å¿—ï¼šè½®è¯¢å…œåº•åŒæ­¥ï¼ˆå³ä½¿æ²¡æœ‰ WebSocket æ¨é€ä¹Ÿèƒ½æ›´æ–°ï¼‰==========
    let faultLogPollTimer = null;

    async function pollFaultLogFromApi() {
        try {
            const resp = await fetch('/api/faults');
            if (!resp.ok) return;
            const result = await resp.json();
            const faults = Array.isArray(result.faults) ? result.faults : [];

            // åªå–æœ€æ–°20æ¡å³å¯ï¼Œå‡å°‘è´Ÿè½½ï¼›å€’åºæ’å…¥æ—¶ä¿æŒâ€œæœ€æ–°åœ¨é¡¶éƒ¨â€
            const latest = faults.slice(0, 20).reverse();
            for (const f of latest) {
                const code = f.fault_code || 'E00';
                if (code === 'E00') continue;
                const nodeId = f.device_id || 'N/A';
                const timeStr = f.time || (f.fault_time ? formatDateTimeForSnapshot(new Date(f.fault_time)) : formatDateTimeForSnapshot(new Date()));
                const st = f.status || 'pending';
                const logId = (f.id !== undefined && f.id !== null) ? f.id : null;
                addLogEntry(nodeId, code, timeStr, st, logId);
            }
            renderFaultLogTable(50);
        } catch (e) {
            // é™é»˜å¤±è´¥ï¼Œé¿å…åˆ·å±
        }
    }

    function startFaultLogPolling() {
        if (faultLogPollTimer) return;
        // æ¯2ç§’åŒæ­¥ä¸€æ¬¡ï¼ˆå…¼é¡¾å®æ—¶æ€§ä¸å¼€é”€ï¼‰
        faultLogPollTimer = setInterval(pollFaultLogFromApi, 2000);
    }
    
    // ========== å…±äº«æ¸²æŸ“é€»è¾‘ï¼ˆè¾…åŠ©å‡½æ•°ï¼‰ ==========
    // ========== æ€§èƒ½ï¼šè°ƒè¯•æ—¥å¿—ä¸å›¾è¡¨æ›´æ–°è°ƒåº¦ ==========
    // è¯´æ˜ï¼š
    // - ä½ æˆªå›¾é‡Œ [renderDashboard]/[updateCharts] çš„ console.log å±äºâ€œé«˜é¢‘æ—¥å¿—â€ï¼Œå¼€ç€ DevTools ä¼šå¯¼è‡´æ—¥å¿—å †ç§¯ï¼Œ
    //   æœ€ç»ˆé¡µé¢å¡æ­»ï¼ˆæµè§ˆå™¨è¦æ¸²æŸ“/ä¿å­˜æµ·é‡ console æ¡ç›®ï¼‰ã€‚
    // - WebSocket é«˜é¢‘æ¨é€ä¸‹ï¼Œæ¯æ¡æ¶ˆæ¯éƒ½ requestAnimationFrame(updateCharts) ä¹Ÿä¼šé€ æˆ ECharts é«˜é¢‘ setOption é‡ç»˜ã€‚
    // è¿™é‡Œåšä¸¤ä»¶äº‹ï¼šé»˜è®¤å…³é—­é«˜é¢‘æ—¥å¿— + åˆå¹¶/é™é¢‘å›¾è¡¨åˆ·æ–°ï¼ˆä¿ç•™æœ€æ–°æ•°æ®å³å¯ï¼‰ã€‚
    const MONITOR_DEBUG_LOG = false;
    function debugLog(...args) {
        if (MONITOR_DEBUG_LOG) console.log(...args);
    }

    let _chartsUpdateScheduled = false;
    let _lastChartsUpdateTs = 0;
    const CHARTS_MAX_HZ = 10; // æœ€å¤š 10Hz åˆ·æ–°å›¾è¡¨ï¼ˆè¶³å¤Ÿå¹³æ»‘ï¼›é˜²æ­¢é«˜é¢‘æ¨é€æŠŠé¡µé¢æ‹–æ­»ï¼‰
    function scheduleChartsUpdate() {
        if (_chartsUpdateScheduled) return;
        _chartsUpdateScheduled = true;
        const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
        const minInterval = 1000 / CHARTS_MAX_HZ;
        const due = _lastChartsUpdateTs + minInterval;
        const delay = Math.max(0, due - now);
        setTimeout(() => {
            requestAnimationFrame(() => {
                _chartsUpdateScheduled = false;
                _lastChartsUpdateTs = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
                if (typeof updateCharts === 'function') updateCharts();
            });
        }, delay);
    }

    function renderDashboard(d) {
        if (!d) {
            console.warn('[renderDashboard] æ•°æ®ä¸ºç©º');
            return;
        }
        
        // A. æ›´æ–°æ–‡æœ¬æ•°å€¼
        const elV  = document.getElementById('val-voltage');
        const elVn = document.getElementById('val-voltage-neg');
        const elC  = document.getElementById('val-current');
        const elL  = document.getElementById('val-leakage');

        if(elV)  elV.innerText  = parseFloat(d.voltage || 0).toFixed(2);
        if(elVn) elVn.innerText = parseFloat(d.voltage_neg || 0).toFixed(2);
        if(elC)  elC.innerText  = parseFloat(d.current || 0).toFixed(2);
        if(elL)  elL.innerText  = parseFloat(d.leakage || 0).toFixed(3);

        // é˜ˆå€¼å‘Šè­¦ï¼šçº¢ç‚¹ + äº‹ä»¶æç¤ºï¼ˆä¸å½±å“ E01-E05 æ•…éšœç ï¼‰
        applyThresholdAlarms(d);

        // B. æ›´æ–°å›¾è¡¨ï¼ˆåŸºäº currentSourceï¼‰
        let waveKey = `${currentSource}_waveform`;
        let specKey = `${currentSource}_spectrum`;

        // ä¼˜å…ˆä½¿ç”¨æ‰å¹³åŒ–é”®ï¼ˆåç«¯å·²è§£æï¼‰
        let waveData = d[waveKey] || [];
        let specData = d[specKey] || [];
        
        debugLog(`[renderDashboard] æ•°æ®æº: ${currentSource}, æ³¢å½¢æ•°æ®é•¿åº¦: ${waveData.length}, é¢‘è°±æ•°æ®é•¿åº¦: ${specData.length}`);
        
        // å¦‚æœæ‰å¹³åŒ–é”®æ²¡æœ‰æ•°æ®ï¼Œä» channels æ•°ç»„è·å–ï¼ˆå‘åå…¼å®¹ï¼‰
        if ((!waveData || waveData.length === 0) && d.channels && Array.isArray(d.channels) && d.channels.length > 0) {
            const sourceToIndex = {'voltage': 0, 'voltage_neg': 1, 'current': 2, 'leakage': 3};
            const channelIndex = sourceToIndex[currentSource] || 0;
            const channel = d.channels[channelIndex];
            
            if (channel) {
                if (channel.waveform && Array.isArray(channel.waveform) && channel.waveform.length > 0) {
                    waveData = channel.waveform;
                    // ä¼˜åŒ–ï¼šå‡å°‘æ—¥å¿—è¾“å‡º
                    // console.log(`[renderDashboard] ä»channelsæ•°ç»„è·å–æ³¢å½¢æ•°æ®ï¼Œé•¿åº¦: ${waveData.length}`);
                }
                if (channel.fft_spectrum && Array.isArray(channel.fft_spectrum) && channel.fft_spectrum.length > 0) {
                    specData = channel.fft_spectrum;
                }
            }
        }
        
        // C. æ›´æ–° nodeData ç¼“å­˜ï¼ˆä¾› updateCharts ä½¿ç”¨ï¼‰
        if (currentNodeId) {
            if (!nodeData[currentNodeId]) {
                nodeData[currentNodeId] = {};
            }
            const sourceToIndex = {'voltage': 0, 'voltage_neg': 1, 'current': 2, 'leakage': 3};
            currentChannelIndex = sourceToIndex[currentSource] || 0;
            
            if (!nodeData[currentNodeId][currentChannelIndex]) {
                nodeData[currentNodeId][currentChannelIndex] = {};
            }
            nodeData[currentNodeId][currentChannelIndex].waveform = waveData;
            nodeData[currentNodeId][currentChannelIndex].fft_spectrum = specData;
            
            // ä¼˜åŒ–ï¼šå‡å°‘æ—¥å¿—è¾“å‡º
            // console.log(`[renderDashboard] å·²æ›´æ–°nodeDataç¼“å­˜: è¾¹ç¼˜èŠ‚ç‚¹=${currentNodeId}, é€šé“ç´¢å¼•=${currentChannelIndex}, æ³¢å½¢é•¿åº¦=${waveData.length}`);
        } else {
            console.warn('[renderDashboard] currentNodeIdä¸ºç©ºï¼Œæ— æ³•æ›´æ–°ç¼“å­˜');
        }
        
        // D. å›¾è¡¨æ›´æ–°ï¼šåˆå¹¶/é™é¢‘ï¼ˆé¿å…é«˜é¢‘æ¨é€å¯¼è‡´ setOption è¿‡å¯† + DevTools å¡æ­»ï¼‰
        scheduleChartsUpdate();
    }

    // ========== ç”¨æˆ·äº¤äº’ï¼šå³æ—¶åˆ‡æ¢ï¼ˆå¸¦è§†è§‰ç¡®è®¤ï¼‰ ==========
    window.selectSource = function(source) {
        currentSource = source;
        
        // 1. é‡ç½®æ‰€æœ‰å¡ç‰‡
        document.querySelectorAll('.card-select').forEach(el => {
            el.classList.remove('card-active'); // ç§»é™¤é«˜äº®
        });
        
        // 2. æ¿€æ´»ç›®æ ‡å¡ç‰‡
        const activeId = source === 'voltage_neg' ? 'card-voltage_neg' : `card-${source}`;
        const el = document.getElementById(activeId);
        if(el) {
            el.classList.add('card-active'); // è¿™ä¼šè§¦å‘CSSæ˜¾ç¤ºå¾½ç« 
        }

        console.log(`ğŸ‘ï¸ View switched to: ${source}`);

        // 3. ç«‹å³æ¸²æŸ“ï¼ˆä½¿ç”¨ç¼“å­˜ï¼‰
        if (lastCachedData) {
            renderDashboard(lastCachedData);
        }
    };

    // ========== åˆå§‹åŒ–æ‰€æœ‰è¾¹ç¼˜èŠ‚ç‚¹æ•°æ® ==========
    function initializeAllNodeData() {
        Object.keys(NODE_CONFIGS).forEach(nodeId => {
            if (!nodeData[nodeId]) {
                nodeData[nodeId] = {};
            }
            const node = NODE_CONFIGS[nodeId];
            
            node.channels.forEach(channel => {
                if (!nodeData[nodeId][channel.id]) {
                    // ä½¿ç”¨ä»åç«¯æ¥æ”¶çš„æ•°æ®ï¼ˆå¦‚æœå¯ç”¨ï¼‰ï¼Œå¦åˆ™ä½¿ç”¨é»˜è®¤å€¼
                    nodeData[nodeId][channel.id] = {
                        currentValue: channel.currentValue || 0,
                        waveform: channel.waveform || [],  // ä»åç«¯æ¥æ”¶çš„æ³¢å½¢æ•°æ®
                        fft_spectrum: channel.fft_spectrum || []  // ä»åç«¯æ¥æ”¶çš„FFTæ•°æ®
                    };
                }
            });
        });
    }

    // ========== æ³¨æ„ï¼šä¸å†ç”Ÿæˆéšæœºæ•°æ®ï¼æ‰€æœ‰æ•°æ®éƒ½ä»åç«¯æ¥æ”¶ ==========
    // å‰ç«¯åªè´Ÿè´£æ¸²æŸ“ä»åç«¯æ¥æ”¶çš„waveformå’Œfft_spectrumæ•°æ®

    // ========== WebSocket å®æ—¶æ¨é€ç³»ç»Ÿ ==========
    function initWebSocket() {
        if (typeof io === 'undefined') {
            console.error('âŒ Socket.IOæœªåŠ è½½ï¼Œå›é€€åˆ°HTTPè½®è¯¢æ¨¡å¼');
            // å›é€€åˆ°è½®è¯¢æ¨¡å¼
            startPollingFallback();
            return;
        }
        
        // è¿æ¥åˆ°WebSocketæœåŠ¡å™¨
        socket = io();
        
        // ========== æ€§èƒ½ç›‘æ§å˜é‡ ==========
        let perfStats = {
            lastUpdateTime: 0,
            updateCount: 0,
            refreshRate: 0,
            renderTimeTotal: 0,
            renderCount: 0
        };
        
        // æ›´æ–°æ€§èƒ½ç›‘æ§é¢æ¿
        function updatePerfPanel() {
            // æ›´æ–°åˆ·æ–°ç‡
            document.getElementById('perf-refresh-rate').textContent = 
                perfStats.refreshRate.toFixed(1) + ' Hz';
            
            // æ›´æ–°WebSocketçŠ¶æ€
            const wsStatus = document.getElementById('perf-ws-status');
            if (socket && socket.connected) {
                wsStatus.innerHTML = '<span class="badge bg-success">å·²è¿æ¥</span>';
            } else {
                wsStatus.innerHTML = '<span class="badge bg-secondary">æœªè¿æ¥</span>';
            }
            
            // æ›´æ–°è®¢é˜…èŠ‚ç‚¹
            document.getElementById('perf-subscribed-node').textContent = 
                currentNodeId || 'æ— ';
            
            // æ›´æ–°æ¸²æŸ“å»¶è¿Ÿ
            const avgRenderTime = perfStats.renderCount > 0 ? 
                (perfStats.renderTimeTotal / perfStats.renderCount) : 0;
            document.getElementById('perf-render-time').textContent = 
                avgRenderTime.toFixed(1) + ' ms';
        }
        
        // æ¯ç§’æ›´æ–°ä¸€æ¬¡æ€§èƒ½é¢æ¿
        setInterval(updatePerfPanel, 1000);
        
        socket.on('connect', () => {
            console.log('âš¡ [WebSocket] å®æ—¶æ¨é€è¿æ¥å·²å»ºç«‹ï¼');
            updatePerfPanel();  // ç«‹å³æ›´æ–°çŠ¶æ€
            
            // å¦‚æœå·²é€‰æ‹©è¾¹ç¼˜èŠ‚ç‚¹ï¼Œç«‹å³è®¢é˜…
            if (currentNodeId) {
                console.log(`[WebSocket] è®¢é˜…èŠ‚ç‚¹: ${currentNodeId}`);
                socket.emit('subscribe_node', { node_id: currentNodeId });
            }
        });
        
        socket.on('disconnect', () => {
            console.warn('âš ï¸ [WebSocket] è¿æ¥æ–­å¼€ï¼Œå›é€€åˆ°HTTPè½®è¯¢æ¨¡å¼');
            startPollingFallback();
        });
        
        socket.on('connect_error', (error) => {
            console.error('âŒ [WebSocket] è¿æ¥é”™è¯¯:', error);
            console.log('ğŸ”„ [WebSocket] å›é€€åˆ°HTTPè½®è¯¢æ¨¡å¼');
            startPollingFallback();
        });
        
        // è¾…åŠ©å‡½æ•°ï¼šä»æ•…éšœä»£ç è·å–æ•…éšœç±»å‹åç§°ï¼ˆç”¨äºæ•…éšœé€šçŸ¥ï¼‰
        function getFaultTypeNameFromCode(faultCode) {
            const faultNames = {
                'E01': 'äº¤æµçªœå…¥',
                'E02': 'ç»ç¼˜æ•…éšœ',
                'E03': 'ç›´æµæ¯çº¿ç”µå®¹è€åŒ–',
                'E04': 'å˜æµå™¨IGBTå¼€è·¯',
                'E05': 'ç›´æµæ¯çº¿æ¥åœ°æ•…éšœ'
            };
            return faultNames[faultCode] || `æ•…éšœ ${faultCode}`;
        }
        
        // ========== æ€§èƒ½ä¼˜åŒ–ï¼šèŠ‚æµå‡½æ•°ï¼ˆThrottleï¼‰ ==========
        function throttle(func, delay) {
            let lastCall = 0;
            let timeout = null;
            return function(...args) {
                const now = Date.now();
                if (now - lastCall >= delay) {
                    lastCall = now;
                    func.apply(this, args);
                } else {
                    // ç¡®ä¿æœ€åä¸€æ¬¡è°ƒç”¨èƒ½å¤Ÿæ‰§è¡Œ
                    clearTimeout(timeout);
                    timeout = setTimeout(() => {
                        lastCall = Date.now();
                        func.apply(this, args);
                    }, delay - (now - lastCall));
                }
            };
        }
        
        // ========== æ¥æ”¶èŠ‚ç‚¹çŠ¶æ€åˆ—è¡¨ï¼ˆè¿æ¥æ—¶ï¼‰ ==========
        socket.on('node_status_list', (msg) => {
            console.log('ğŸ“‹ [WebSocket] æ¥æ”¶èŠ‚ç‚¹çŠ¶æ€åˆ—è¡¨:', msg.nodes.length, 'ä¸ªèŠ‚ç‚¹');
            // æ‰¹é‡æ›´æ–°èŠ‚ç‚¹åˆ—è¡¨ï¼ˆä¸è§¦å‘é‡ç»˜ï¼‰
            if (msg.nodes && msg.nodes.length > 0) {
                msg.nodes.forEach(node => {
                    if (NODE_CONFIGS[node.node_id]) {
                        NODE_CONFIGS[node.node_id].status = node.status;
                        NODE_CONFIGS[node.node_id].fault_code = node.fault_code;
                    }
                    // å…³é”®ä¿®å¤ï¼šåˆå§‹åŒ–æ•…éšœå†å²è®°å½•ï¼Œé¿å…è¯¯è§¦å‘å¼¹çª—
                    nodeFaultHistory[node.node_id] = node.fault_code || 'E00';
                });
                // ä¸€æ¬¡æ€§é‡æ–°æ¸²æŸ“èŠ‚ç‚¹åˆ—è¡¨
                renderNodeList();
            }
        });
        
        // ========== è½»é‡çº§çŠ¶æ€æ›´æ–°ï¼ˆæ‰€æœ‰èŠ‚ç‚¹ï¼Œä»…çŠ¶æ€ï¼‰ ==========
        // ä½¿ç”¨èŠ‚æµé™åˆ¶æ›´æ–°é¢‘ç‡ï¼Œé¿å…é¢‘ç¹DOMæ“ä½œ
        const throttledStatusUpdate = throttle((msg) => {
            const nodeId = msg.node_id;
            const currentCode = msg.fault_code || 'E00';
            const lastCode = nodeFaultHistory[nodeId];
            
            // æ›´æ–°å†…å­˜ä¸­çš„çŠ¶æ€
            if (NODE_CONFIGS[nodeId]) {
                NODE_CONFIGS[nodeId].status = msg.status;
                NODE_CONFIGS[nodeId].fault_code = msg.fault_code;
            }
            
            // ========== ç³»ç»Ÿæ•…éšœæ—¥å¿—ï¼ˆå…¨å±€ï¼‰ï¼šå¯¹æ‰€æœ‰èŠ‚ç‚¹çš„æ•…éšœç å˜åŒ–è¿›è¡Œè®°å½• ==========
            // è¯´æ˜ï¼šmonitor_update åªå¯¹â€œå½“å‰è®¢é˜…èŠ‚ç‚¹â€æ¨é€ï¼Œæ— æ³•è¦†ç›–å…¨ç³»ç»Ÿã€‚
            // node_status_update æ˜¯å…¨å±€æ¨é€ï¼ˆæ‰€æœ‰èŠ‚ç‚¹ï¼‰ï¼Œå› æ­¤ç³»ç»Ÿæ•…éšœæ—¥å¿—åº”ä»¥å®ƒä¸ºå‡†ã€‚
            if (lastCode === undefined) {
                // é¦–æ¬¡è§åˆ°è¯¥èŠ‚ç‚¹ï¼šè‹¥ä¸€ä¸Šæ¥å°±æ˜¯æ•…éšœæ€ï¼Œç›´æ¥è®°ä¸€æ¡
                if (currentCode !== 'E00') {
                    addLogEntry(nodeId, currentCode, formatDateTimeForSnapshot(new Date()));
                }
            } else if (lastCode !== currentCode) {
                // çŠ¶æ€å˜åŒ–ï¼šè®°å½•æ•…éšœ/æ¢å¤
                addLogEntry(nodeId, currentCode, formatDateTimeForSnapshot(new Date()));
            }

            // åŒæ­¥æ›´æ–°æ•…éšœå†å²è®°å½•ï¼ˆæ”¾åœ¨æ—¥å¿—è®°å½•ä¹‹åï¼Œé¿å…é‡å¤ï¼‰
            nodeFaultHistory[nodeId] = currentCode;
            
            // åªæ›´æ–°ä¾§è¾¹æ ä¸­å¯¹åº”èŠ‚ç‚¹çš„å¾½ç« ï¼ˆå±€éƒ¨æ›´æ–°ï¼Œä¸é‡ç»˜æ•´ä¸ªåˆ—è¡¨ï¼‰
            const nodeList = document.getElementById('nodeList');
            const listItem = findNodeListItem(nodeList, nodeId);
            if (listItem) {
                // æ³¨æ„ï¼šèŠ‚ç‚¹åˆ—è¡¨æœ¬èº«ä½¿ç”¨ renderNodeList() æ¸²æŸ“çš„æ˜¯â€œå•ä¸€å¾½ç« â€(#badge-nodeId)
                // ä¹‹å‰è¿™é‡ŒåŒæ—¶æŠŠåŒä¸€ä¸ªå¾½ç« å½“ä½œâ€œåœ¨çº¿çŠ¶æ€â€å’Œâ€œæ•…éšœçŠ¶æ€â€æ›´æ–°ï¼Œå¯¼è‡´æ–‡æœ¬åœ¨â€œåœ¨çº¿/æ­£å¸¸â€ä¹‹é—´è·³åŠ¨
                const badge = listItem.querySelector(`#${badgeDomId(nodeId)}`);
                
                // å¿«é€ŸDOMæ›´æ–°ï¼ˆå‡å°‘é‡æ’ï¼‰
                requestAnimationFrame(() => {
                    if (!badge) return;
                    
                    const status = msg.status || 'offline';
                    const faultCode = msg.fault_code || 'E00';
                    const isFault = (faultCode && faultCode !== 'E00') || status === 'fault' || status === 'faulty';
                    
                    let badgeClass, badgeText, badgeIcon;
                    if (isFault) {
                        badgeClass = 'bg-danger';
                        badgeText = faultCode;
                        badgeIcon = 'âš ';
                    } else if (status === 'online') {
                        badgeClass = 'bg-success';
                        badgeText = 'æ­£å¸¸';
                        badgeIcon = 'â—';
                    } else {
                        badgeClass = 'bg-secondary';
                        badgeText = 'ç¦»çº¿';
                        badgeIcon = 'â—‹';
                    }
                    
                    const targetText = `${badgeIcon} ${badgeText}`;
                    const currentText = badge.textContent.trim();
                    const currentClass = badge.classList.contains('bg-danger') ? 'bg-danger' :
                                         badge.classList.contains('bg-success') ? 'bg-success' : 'bg-secondary';
                    
                    if (currentClass !== badgeClass || currentText !== targetText) {
                        badge.classList.remove('bg-danger', 'bg-success', 'bg-secondary');
                        badge.classList.add(badgeClass);
                        badge.textContent = targetText;
                    }
                });
            }
            
            // å¦‚æœæ˜¯å½“å‰é€‰ä¸­èŠ‚ç‚¹ï¼Œæ›´æ–°å…³é”®æŒ‡æ ‡å¡ç‰‡
            if (currentNodeId === nodeId && msg.metrics) {
                updateMetricsCards(msg.metrics);
            }
        }, 200);  // 200msèŠ‚æµé—´éš”
        
        socket.on('node_status_update', throttledStatusUpdate);
        
        // ========== æ€§èƒ½ä¼˜åŒ–ï¼šæ‰¹é‡æ›´æ–°å…³é”®æŒ‡æ ‡å¡ç‰‡ ==========
        function updateMetricsCards(metrics) {
            const cards = {
                'voltage': metrics.voltage,
                'voltage_neg': metrics.voltage_neg,
                'current': metrics.current,
                'leakage': metrics.leakage
            };
            
            // ä½¿ç”¨DocumentFragmentæ‰¹é‡æ›´æ–°ï¼Œå‡å°‘é‡æ’
            requestAnimationFrame(() => {
                for (const [key, value] of Object.entries(cards)) {
                    const element = document.getElementById(`current-${key}`);
                    if (element) {
                        element.textContent = (value || 0).toFixed(2);
                    }
                }
            });
        }
        
        // Global Socket Listener - ä¼˜åŒ–ç‰ˆæœ¬ï¼šä½¿ç”¨requestAnimationFrameæ‰¹å¤„ç†æ›´æ–°
        let pendingUpdate = null;
        let rafScheduled = false;
        
        socket.on('monitor_update', (msg) => {
            // æ€§èƒ½ç»Ÿè®¡
            const now = Date.now();
            perfStats.updateCount++;
            if (perfStats.lastUpdateTime > 0) {
                const delta = now - perfStats.lastUpdateTime;
                if (delta > 0) {
                    // è®¡ç®—ç§»åŠ¨å¹³å‡åˆ·æ–°ç‡
                    const instantRate = 1000 / delta;
                    perfStats.refreshRate = perfStats.refreshRate * 0.8 + instantRate * 0.2;
                }
            }
            perfStats.lastUpdateTime = now;
            
            try {
                // æ³¨æ„ï¼šç”±äºä½¿ç”¨äº†æˆ¿é—´æœºåˆ¶ï¼Œæ­¤äº‹ä»¶åªä¼šæ¥æ”¶åˆ°è®¢é˜…èŠ‚ç‚¹çš„æ•°æ®
                // å› æ­¤ä¸éœ€è¦æ£€æŸ¥ä¾§è¾¹æ æ›´æ–°

                // 2. æ•…éšœæ£€æµ‹å’Œé€šçŸ¥ï¼ˆç«‹å³æ‰§è¡Œï¼Œæ— å»¶è¿Ÿï¼‰-------------
                const currentCode = msg.data.fault_code || msg.fault_code || 'E00';
                const lastCode = nodeFaultHistory[msg.node_id];
                const isInitial = msg.is_initial === true;  // æ˜¯å¦æ˜¯åˆå§‹è®¢é˜…æ•°æ®

                // è‹¥æ˜¯åˆå§‹æ•°æ®ä¸”å½“å‰å°±æ˜¯æ•…éšœï¼ˆE01-E05ï¼‰ï¼Œä¹Ÿè®°å½•ä¸€æ¬¡ï¼ˆé¿å…â€œæœ‰æ•…éšœä½†è¡¨ä¸ºç©ºâ€ï¼‰
                if (isInitial && currentCode !== 'E00' && !faultLogHistoryLoaded) {
                    const timeStrInit = formatDateTimeForSnapshot(new Date());
                    addLogEntry(msg.node_id, currentCode, timeStrInit);
                }
                
                // æ£€æµ‹æ•…éšœçŠ¶æ€å˜åŒ–ï¼ˆç«‹å³è§¦å‘ï¼Œä¸ç­‰å¾…è½®è¯¢ï¼‰
                // å…³é”®ä¿®å¤ï¼šæ’é™¤åˆå§‹è®¢é˜…æ•°æ®ï¼Œé¿å…è¯¯è§¦å‘å¼¹çª—
                if (!isInitial && lastCode !== undefined && lastCode !== currentCode) {
                    const timeStr = formatDateTimeForSnapshot(new Date());
                    addLogEntry(msg.node_id, currentCode, timeStr);
                    
                    // å…³é”®ä¼˜åŒ–ï¼šç«‹å³æ£€æµ‹å¹¶è§¦å‘æ•…éšœå¼¹çª—ï¼ˆä»æ­£å¸¸åˆ°æ•…éšœï¼‰
                    if (lastCode === 'E00' && currentCode !== 'E00') {
                        // è·å–æ•…éšœç±»å‹åç§°
                        const faultTypeName = getFaultTypeNameFromCode(currentCode);
                        // ç«‹å³è§¦å‘æ•…éšœé€šçŸ¥ï¼Œä½¿ç”¨requestAnimationFrameç¡®ä¿æœ€å¿«æ˜¾ç¤º
                        if (typeof window.publishSystemEvent === 'function') {
                            // åŒæ­¥æ›´æ–°å…¨å±€çŠ¶æ€ï¼Œé¿å…è½®è¯¢æ—¶é‡å¤é€šçŸ¥
                            if (window.globalLastNodeStates) {
                                window.globalLastNodeStates[msg.node_id] = {
                                    fault_code: currentCode,
                                    status: 'fault'
                                };
                            }
                            // ç«‹å³æ˜¾ç¤ºå¼¹çª—
                            requestAnimationFrame(() => {
                                window.publishSystemEvent(
                                    `âš ï¸ è¾¹ç¼˜èŠ‚ç‚¹ ${msg.node_id} æ£€æµ‹åˆ°æ•…éšœ: ${faultTypeName} (${currentCode})`,
                                    'error'
                                );
                            });
                        }
                    }
                    // æ£€æµ‹æ•…éšœæ¢å¤ï¼ˆä»æ•…éšœåˆ°æ­£å¸¸ï¼‰
                    else if (lastCode !== 'E00' && currentCode === 'E00') {
                        if (typeof window.publishSystemEvent === 'function') {
                            // åŒæ­¥æ›´æ–°å…¨å±€çŠ¶æ€
                            if (window.globalLastNodeStates) {
                                window.globalLastNodeStates[msg.node_id] = {
                                    fault_code: 'E00',
                                    status: 'online'
                                };
                            }
                            // ç«‹å³æ˜¾ç¤ºæ¢å¤é€šçŸ¥
                            requestAnimationFrame(() => {
                                window.publishSystemEvent(
                                    `âœ… è¾¹ç¼˜èŠ‚ç‚¹ ${msg.node_id} æ•…éšœå·²æ¸…é™¤ï¼Œæ¢å¤æ­£å¸¸çŠ¶æ€`,
                                    'success'
                                );
                            });
                        }
                    }
                }
                // æ›´æ–°å†å²è®°å½•ï¼ˆåŒ…æ‹¬åˆå§‹è®¢é˜…æ•°æ®ï¼‰
                nodeFaultHistory[msg.node_id] = currentCode;
                // ------------------------------------------

                // 3. Update Main View - ä½¿ç”¨requestAnimationFrameæ‰¹å¤„ç†ï¼Œå‡å°‘é‡ç»˜
                if (currentNodeId && msg.node_id === currentNodeId) {
                    const d = msg.data;
                    
                    // ç¼“å­˜æœ€æ–°æ•°æ®åŒ…
                    lastCachedData = d;
                    
                    // ä¼˜åŒ–ï¼šä½¿ç”¨requestAnimationFrameæ‰¹å¤„ç†æ›´æ–°ï¼Œé¿å…é¢‘ç¹é‡ç»˜
                    pendingUpdate = d;
                    if (!rafScheduled) {
                        rafScheduled = true;
                        const renderStart = performance.now();
                        requestAnimationFrame(() => {
                            if (pendingUpdate) {
                                renderDashboard(pendingUpdate);
                                
                                // è®°å½•æ¸²æŸ“æ—¶é—´
                                const renderTime = performance.now() - renderStart;
                                perfStats.renderTimeTotal += renderTime;
                                perfStats.renderCount++;
                                // ä¿æŒæœ€è¿‘100æ¬¡çš„å¹³å‡å€¼
                                if (perfStats.renderCount > 100) {
                                    perfStats.renderTimeTotal *= 0.99;
                                    perfStats.renderCount *= 0.99;
                                }
                                
                                pendingUpdate = null;
                            }
                            rafScheduled = false;
                        });
                    }
                } else if (!currentNodeId) {
                    // è‡ªåŠ¨é€‰æ‹©ç¬¬ä¸€ä¸ªæ´»åŠ¨è¾¹ç¼˜èŠ‚ç‚¹
                    currentNodeId = msg.node_id;
                    lastCachedData = msg.data;
                    renderDashboard(lastCachedData);
                    updatePerfPanel();  // æ›´æ–°æ€§èƒ½é¢æ¿
                }
            } catch (e) {
                console.error("ğŸ”¥ Monitor Update Error:", e);
            }
        });
        
        // å®šæœŸè·å–è¾¹ç¼˜èŠ‚ç‚¹åˆ—è¡¨ï¼ˆä½œä¸ºWebSocketçš„è¡¥å……ï¼Œç¡®ä¿è¾¹ç¼˜èŠ‚ç‚¹åˆ—è¡¨å®Œæ•´ï¼‰
        nodeListInterval = setInterval(fetchActiveNodes, 5000);  // 5ç§’è·å–ä¸€æ¬¡è¾¹ç¼˜èŠ‚ç‚¹åˆ—è¡¨
    }

    // ========== æ—¶é—´æ ¼å¼åŒ–ï¼šç”¨äºæ•…éšœå¿«ç…§äº‹ä»¶å®šä½ ==========
    // ç»Ÿä¸€ä½¿ç”¨åŒ—äº¬æ—¶é—´ï¼ˆAsia/Shanghaiï¼‰ï¼Œé¿å…æµè§ˆå™¨æœ¬åœ°æ—¶åŒºå¯¼è‡´â€œå·®8å°æ—¶/å·®7å°æ—¶â€
    // å¿«ç…§äº‹ä»¶APIä½¿ç”¨æœ¬åœ°æ—¶é—´å­—ç¬¦ä¸²ï¼šYYYY-MM-DD HH:MM:SS
    function formatDateTimeForSnapshot(dt) {
        const d = (dt instanceof Date) ? dt : new Date(dt || Date.now());
        const parts = new Intl.DateTimeFormat('zh-CN', {
            timeZone: 'Asia/Shanghai',
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            hour12: false
        }).formatToParts(d);

        const map = {};
        parts.forEach(p => { map[p.type] = p.value; });
        return `${map.year}-${map.month}-${map.day} ${map.hour}:${map.minute}:${map.second}`;
    }
    
    // å›é€€åˆ°HTTPè½®è¯¢æ¨¡å¼ï¼ˆå½“WebSocketä¸å¯ç”¨æ—¶ï¼‰- ä¼˜åŒ–ï¼šä½¿ç”¨æ›´å¿«çš„è½®è¯¢
    function startPollingFallback() {
        console.log('[Monitor] ä½¿ç”¨HTTPè½®è¯¢æ¨¡å¼ï¼ˆå›é€€ï¼‰');
        // ä¼˜åŒ–ï¼šä½¿ç”¨æ›´å¿«çš„è½®è¯¢é—´éš”ï¼ˆ50msï¼Œæ¥è¿‘æ¨¡æ‹Ÿå™¨çš„20msä¸Šä¼ é¢‘ç‡ï¼‰
        const interval = parseInt(localStorage.getItem('pollInterval')) || 50;  // ä»1000msæ”¹ä¸º50ms
        if (nodeListInterval) clearInterval(nodeListInterval);
        if (updateInterval) clearInterval(updateInterval);
        nodeListInterval = setInterval(fetchActiveNodes, 5000);  // è¾¹ç¼˜èŠ‚ç‚¹åˆ—è¡¨5ç§’æ›´æ–°ä¸€æ¬¡å³å¯
        updateInterval = setInterval(updateAllNodesData, interval);  // æ•°æ®æ›´æ–°ä½¿ç”¨å¿«é€Ÿè½®è¯¢
    }
    
    // æš´éœ²restartPollingå‡½æ•°åˆ°å…¨å±€ï¼ˆå‘åå…¼å®¹ï¼‰
    window.restartPolling = function() {
        console.log('[Monitor] é‡æ–°åˆå§‹åŒ–WebSocketè¿æ¥...');
        if (socket) {
            socket.disconnect();
        }
        initWebSocket();
    };
    
    
    
    // ========== ä»WebSocketæ•°æ®æ›´æ–°é€šé“å¡ç‰‡ ==========
    function updateChannelCardsFromData(data) {
        if (!currentNodeId || !data) return;
        
        // æ›´æ–°nodeDataç¼“å­˜
        if (!nodeData[currentNodeId]) {
            nodeData[currentNodeId] = {};
        }
        
        // ä¼˜å…ˆä½¿ç”¨ channels æ•°ç»„ï¼ˆæ ‡å‡†æ•°æ®æ ¼å¼ï¼‰
        if (data.channels && Array.isArray(data.channels) && data.channels.length > 0) {
            data.channels.forEach(channel => {
                if (!nodeData[currentNodeId][channel.id]) {
                    nodeData[currentNodeId][channel.id] = {};
                }
                // æ”¯æŒå¤šç§å­—æ®µåï¼ˆcurrentValue æˆ– valueï¼‰
                const currentValue = channel.currentValue !== undefined ? channel.currentValue :
                                   channel.value !== undefined ? channel.value : 0;
                
                nodeData[currentNodeId][channel.id].currentValue = parseFloat(currentValue) || 0;
                nodeData[currentNodeId][channel.id].waveform = channel.waveform || [];
                nodeData[currentNodeId][channel.id].fft_spectrum = channel.fft_spectrum || [];
                
                // åŒæ—¶æ›´æ–° NODE_CONFIGS ä¸­çš„é€šé“æ•°æ®ï¼ˆç¡®ä¿æ•°æ®åŒæ­¥ï¼‰
                if (NODE_CONFIGS[currentNodeId] && NODE_CONFIGS[currentNodeId].channels) {
                    const configChannel = NODE_CONFIGS[currentNodeId].channels.find(ch => ch.id === channel.id);
                    if (configChannel) {
                        configChannel.currentValue = parseFloat(currentValue) || 0;
                        configChannel.waveform = channel.waveform || [];
                        configChannel.fft_spectrum = channel.fft_spectrum || [];
                    }
                }
            });
        } else {
            // å‘åå…¼å®¹ï¼šå¦‚æœæ²¡æœ‰ channels æ•°ç»„ï¼Œå°è¯•ä½¿ç”¨ç›´æ¥å­—æ®µ
            console.warn('[updateChannelCardsFromData] æœªæ‰¾åˆ° channels æ•°ç»„');
        }
    }
    
    // ========== ä»WebSocketæ•°æ®æ›´æ–°å›¾è¡¨ ==========
    function updateChartsFromData(data) {
        if (!currentNodeId || !data || !data.channels) return;
        
        // æ›´æ–°nodeDataç¼“å­˜
        updateChannelCardsFromData(data);
        
        // æ›´æ–°å›¾è¡¨
        updateCharts();
    }
    
    // ========== æ›´æ–°è¾¹ç¼˜èŠ‚ç‚¹åˆ—è¡¨çŠ¶æ€ï¼ˆWebSocketæ¨é€æ—¶è°ƒç”¨ï¼‰==========
    function updateNodeListStatus(nodeId, data) {
        // æ›´æ–°NODE_CONFIGSä¸­çš„çŠ¶æ€
        if (NODE_CONFIGS[nodeId]) {
            if (data.status) NODE_CONFIGS[nodeId].status = data.status;
            if (data.fault_code) NODE_CONFIGS[nodeId].fault_code = data.fault_code;
        }
        
        // ä½¿ç”¨ç¨³å®šçš„å°±åœ°æ›´æ–°ï¼ˆä¸ä¼šå¯¼è‡´åˆ—è¡¨è·³åŠ¨ï¼‰
        const nodeList = document.getElementById('nodeList');
        const listItem = findNodeListItem(nodeList, nodeId);
        if (listItem) {
            const status = data.status || NODE_CONFIGS[nodeId]?.status || 'offline';
            const faultCode = data.fault_code || NODE_CONFIGS[nodeId]?.fault_code || 'E00';
            const isFault = status === 'fault' || status === 'faulty';
            
            // ç¡®å®šçŠ¶æ€å¾½ç« æ ·å¼
            let badgeClass, badgeText, badgeIcon;
            if (isFault) {
                badgeClass = 'bg-danger';
                badgeText = faultCode;
                badgeIcon = 'âš ';
            } else if (status === 'online') {
                badgeClass = 'bg-success';
                badgeText = 'åœ¨çº¿';
                badgeIcon = 'â—';
            } else {
                badgeClass = 'bg-secondary';
                badgeText = 'ç¦»çº¿';
                badgeIcon = 'â—‹';
            }
            
            // åªæ›´æ–°badgeï¼ˆæœ€å°åŒ–DOMæ“ä½œï¼‰
            const badge = listItem.querySelector(`#${badgeDomId(nodeId)}`);
            if (badge) {
                const currentBadgeClass = badge.classList.contains('bg-danger') ? 'bg-danger' :
                                         badge.classList.contains('bg-success') ? 'bg-success' : 'bg-secondary';
                const targetBadgeText = `${badgeIcon} ${badgeText}`;
                
                if (currentBadgeClass !== badgeClass) {
                    badge.classList.remove('bg-danger', 'bg-success', 'bg-secondary');
                    badge.classList.add(badgeClass);
                }
                if (badge.textContent.trim() !== targetBadgeText) {
                    badge.textContent = targetBadgeText;
                }
            }
            
            // æ›´æ–°æ•…éšœè„‰å†²åŠ¨ç”»
            const shouldHavePulse = isFault;
            const hasPulse = listItem.classList.contains('fault-pulse');
            if (shouldHavePulse !== hasPulse) {
                if (shouldHavePulse) {
                    listItem.classList.add('fault-pulse');
                } else {
                    listItem.classList.remove('fault-pulse');
                }
            }
        } else {
            // å¦‚æœå…ƒç´ ä¸å­˜åœ¨ï¼Œè°ƒç”¨å®Œæ•´æ¸²æŸ“ï¼ˆä½†ä¼šä½¿ç”¨ç¨³å®šæ’åºï¼‰
            renderNodeList();
        }
    }

    // ========== æ›´æ–°æ‰€æœ‰è¾¹ç¼˜èŠ‚ç‚¹æ•°æ®ï¼ˆä»…ä»åç«¯æ¥æ”¶çš„æ•°æ®ï¼‰==========
    function updateAllNodesData() {
        try {
            // ä»NODE_CONFIGSä¸­è¯»å–æ•°æ®ï¼ˆç”±å¿ƒè·³æ•°æ®æ›´æ–°ï¼‰
        Object.keys(NODE_CONFIGS).forEach(nodeId => {
            const node = NODE_CONFIGS[nodeId];
                if (!node) return;
                
            node.channels.forEach(channel => {
                if (!nodeData[nodeId]) nodeData[nodeId] = {};
                    
                    // ç›´æ¥ä½¿ç”¨ä»åç«¯æ¥æ”¶çš„æ•°æ®ï¼ˆä¸ç”Ÿæˆä»»ä½•éšæœºæ•°æ®ï¼‰
                    const currentValue = channel.currentValue !== undefined ? channel.currentValue : 0;
                    const waveform = channel.waveform || [];  // ä»åç«¯æ¥æ”¶çš„æ³¢å½¢æ•°ç»„
                    const fft_spectrum = channel.fft_spectrum || [];  // ä»åç«¯æ¥æ”¶çš„FFTæ•°ç»„
                    
                if (!nodeData[nodeId][channel.id]) {
                    nodeData[nodeId][channel.id] = {
                            currentValue: currentValue,
                            waveform: waveform,
                            fft_spectrum: fft_spectrum
                    };
                    } else {
                        // æ›´æ–°æ•°æ®ï¼ˆç›´æ¥ä½¿ç”¨åç«¯æ•°æ®ï¼Œä¸ç”Ÿæˆï¼‰
                        nodeData[nodeId][channel.id].currentValue = currentValue;
                        nodeData[nodeId][channel.id].waveform = waveform;
                        nodeData[nodeId][channel.id].fft_spectrum = fft_spectrum;
                }
            });
        });
        
        // åªæ›´æ–°å½“å‰è¾¹ç¼˜èŠ‚ç‚¹çš„é€šé“å¡ç‰‡æ˜¾ç¤º
            if (currentNodeId && NODE_CONFIGS[currentNodeId]) {
            const node = NODE_CONFIGS[currentNodeId];
            node.channels.forEach((channel, index) => {
                const valueElement = document.getElementById(`channel-card-value-${currentNodeId}-${index}`);
                if (valueElement) {
                    const channelData = nodeData[currentNodeId][channel.id];
                        if (channelData) {
                    valueElement.textContent = formatValue(channelData.currentValue, channel.unit);
                        }
                }
            });
        }
        
            // æ›´æ–°å›¾è¡¨ï¼ˆä»…åœ¨å½“å‰è¾¹ç¼˜èŠ‚ç‚¹å­˜åœ¨æ—¶ï¼‰
        if (currentNodeId) {
            updateCharts();
            }
        } catch (error) {
            console.error('[updateAllNodesData] æ›´æ–°è¾¹ç¼˜èŠ‚ç‚¹æ•°æ®æ—¶å‡ºé”™:', error);
            // é”™è¯¯ä¸å½±å“åç»­æ›´æ–°ï¼Œç»§ç»­æ‰§è¡Œ
        }
    }

    // ========== åˆ‡æ¢å›¾è¡¨æ ‡ç­¾é¡µ ==========
    function switchChartTab(tab) {
        activeTab = tab;
        
        // åˆ‡æ¢æ ‡ç­¾é¡µæ¿€æ´»çŠ¶æ€
        const timeTab = document.getElementById('timeTab');
        const freqTab = document.getElementById('freqTab');
        const timePane = document.getElementById('timeChartPane');
        const freqPane = document.getElementById('freqChartPane');
        
        if (tab === 'time') {
            timeTab.classList.add('active');
            timeTab.setAttribute('aria-selected', 'true');
            freqTab.classList.remove('active');
            freqTab.setAttribute('aria-selected', 'false');
            timePane.classList.add('show', 'active');
            freqPane.classList.remove('show', 'active');
            
            // å…³é”®ï¼šæ˜¾ç¤ºåç«‹å³è°ƒæ•´å›¾è¡¨å¤§å°ï¼ˆEChartsæ— æ³•åœ¨éšè—divä¸­è‡ªåŠ¨è°ƒæ•´å¤§å°ï¼‰
            setTimeout(() => {
                if (timeDomainChart) {
                    timeDomainChart.resize();
                    // é‡æ–°åº”ç”¨ç¼©æ”¾ï¼ˆtab åˆ‡æ¢å¯¼è‡´å°ºå¯¸å˜åŒ–æ—¶ï¼ŒgridRect ä¼šå˜åŒ–ï¼‰
                    const timeChartDom = document.getElementById('time-domain-chart');
                    if (timeChartDom && typeof setupChartZoom === 'function') {
                        setupChartZoom(timeDomainChart, timeChartDom);
                    }
                }
            }, 150);
        } else {
            freqTab.classList.add('active');
            freqTab.setAttribute('aria-selected', 'true');
            timeTab.classList.remove('active');
            timeTab.setAttribute('aria-selected', 'false');
            freqPane.classList.add('show', 'active');
            timePane.classList.remove('show', 'active');
            
            // å…³é”®ï¼šæ˜¾ç¤ºåç«‹å³è°ƒæ•´å›¾è¡¨å¤§å°ï¼ˆEChartsæ— æ³•åœ¨éšè—divä¸­è‡ªåŠ¨è°ƒæ•´å¤§å°ï¼‰
            setTimeout(() => {
                if (frequencyDomainChart) {
                    frequencyDomainChart.resize();
                    // é‡æ–°åº”ç”¨ç¼©æ”¾ï¼ˆtab åˆ‡æ¢å¯¼è‡´å°ºå¯¸å˜åŒ–æ—¶ï¼ŒgridRect ä¼šå˜åŒ–ï¼‰
                    const freqChartDom = document.getElementById('frequency-domain-chart');
                    if (freqChartDom && typeof setupChartZoom === 'function') {
                        setupChartZoom(frequencyDomainChart, freqChartDom);
                    }
                }
            }, 150);
        }
        
        // ç«‹å³æ›´æ–°å½“å‰æ˜¾ç¤ºçš„å›¾è¡¨
        updateCharts();
    }

    // ========== æ›´æ–°å›¾è¡¨ ==========
    function updateCharts() {
        try {
            if (!currentNodeId) {
                // å¦‚æœæ²¡æœ‰é€‰ä¸­è¾¹ç¼˜èŠ‚ç‚¹ï¼Œæ¸…ç©ºå›¾è¡¨
                if (timeDomainChart) {
                    timeDomainChart.clear();
                }
                if (frequencyDomainChart) {
                    frequencyDomainChart.clear();
                }
                return;
            }
        
        const node = NODE_CONFIGS[currentNodeId];
            if (!node || !node.channels || node.channels.length === 0) {
                console.warn('[updateCharts] è¾¹ç¼˜èŠ‚ç‚¹æ•°æ®ä¸å®Œæ•´:', currentNodeId);
                return;
            }
            
        // æ ¹æ® currentChannelIndex è·å–å¯¹åº”çš„é€šé“
        const channel = node.channels[currentChannelIndex];
            if (!channel) {
                console.warn('[updateCharts] é€šé“ä¸å­˜åœ¨:', currentChannelIndex, 'è¾¹ç¼˜èŠ‚ç‚¹:', currentNodeId, 'å¯ç”¨é€šé“æ•°:', node.channels.length);
                return;
            }
            
        // ä»ç¼“å­˜ä¸­è·å–å½“å‰é€‰ä¸­é€šé“çš„æ•°æ®ï¼ˆå…³é”®ï¼šä½¿ç”¨ channel.id æˆ– channel.indexï¼‰
        // ä¼˜å…ˆå°è¯•ä½¿ç”¨ channel.idï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨ currentChannelIndex
        let channelId = channel.id !== undefined ? channel.id : currentChannelIndex;
        let data = nodeData[currentNodeId]?.[channelId];
        
        // å¦‚æœä½¿ç”¨ channel.id æ‰¾ä¸åˆ°æ•°æ®ï¼Œå°è¯•ä½¿ç”¨ç´¢å¼•ä½œä¸ºå¤‡ç”¨é”®
        if (!data || (!data.waveform && !data.fft_spectrum)) {
            // å°è¯•ä½¿ç”¨ç´¢å¼•ä½œä¸ºé”®
            data = nodeData[currentNodeId]?.[currentChannelIndex];
            if (data && (data.waveform || data.fft_spectrum)) {
                channelId = currentChannelIndex;
            }
        }
        
        // é«˜é¢‘æ—¥å¿—ä¼šå¯¼è‡´ DevTools å †ç§¯å¡æ­»ï¼›ä»…åœ¨éœ€è¦æ’æŸ¥æ—¶æ‰“å¼€ MONITOR_DEBUG_LOG
        if (!data || (!data.waveform && !data.fft_spectrum)) {
            debugLog(`[updateCharts] è­¦å‘Šï¼šè¾¹ç¼˜èŠ‚ç‚¹ ${currentNodeId} é€šé“ ${currentChannelIndex} (ID: ${channelId}) æ²¡æœ‰æ³¢å½¢/é¢‘è°±æ•°æ®`);
        } else {
            debugLog(`[updateCharts] âœ… è¾¹ç¼˜èŠ‚ç‚¹: ${currentNodeId}, é€šé“ç´¢å¼•: ${currentChannelIndex}, é€šé“ID: ${channelId}, æ³¢å½¢ç‚¹æ•°: ${data.waveform?.length || 0}, FFTç‚¹æ•°: ${data.fft_spectrum?.length || 0}`);
        }
        
        // åªæ›´æ–°å½“å‰æ¿€æ´»çš„æ ‡ç­¾é¡µå›¾è¡¨ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼‰
        if (activeTab === 'time') {
                // æ—¶åŸŸåˆ†æï¼šä½¿ç”¨ waveform æ•°æ®
                const waveform = data?.waveform || [];
                // ä¼˜åŒ–ï¼šå‡å°‘æ—¥å¿—è¾“å‡º
                // console.log(`[updateCharts] å‡†å¤‡æ›´æ–°æ—¶åŸŸå›¾è¡¨ï¼Œæ³¢å½¢æ•°æ®é•¿åº¦: ${waveform.length}`);
                if (waveform.length > 0) {
                    updateTimeDomainChart(waveform, channel);
                }
                // ä¼˜åŒ–ï¼šå‡å°‘è­¦å‘Šæ—¥å¿—
                // else {
                //     console.warn('[updateCharts] æ³¢å½¢æ•°æ®ä¸ºç©ºï¼Œæ— æ³•æ›´æ–°å›¾è¡¨');
                // }
        } else {
                // é¢‘åŸŸåˆ†æï¼šä½¿ç”¨ fft_spectrum æ•°æ®ï¼ˆå…³é”®ä¿®å¤ï¼ï¼‰
                const spectrum = data?.fft_spectrum || [];
                // ä¼˜åŒ–ï¼šå‡å°‘æ—¥å¿—è¾“å‡º
                // console.log(`[updateCharts] å‡†å¤‡æ›´æ–°é¢‘åŸŸå›¾è¡¨ï¼Œé¢‘è°±æ•°æ®é•¿åº¦: ${spectrum.length}`);
                if (spectrum.length > 0) {
                    updateFrequencyDomainChart(spectrum, channel);
                }
                // ä¼˜åŒ–ï¼šå‡å°‘è­¦å‘Šæ—¥å¿—
                // else {
                //     console.warn('[updateCharts] é¢‘è°±æ•°æ®ä¸ºç©ºï¼Œæ— æ³•æ›´æ–°å›¾è¡¨');
                // }
            }
        } catch (error) {
            console.error('[updateCharts] æ›´æ–°å›¾è¡¨æ—¶å‡ºé”™:', error);
            // é”™è¯¯ä¸å½±å“åç»­æ›´æ–°
        }
    }

    // ========== æ›´æ–°æ—¶åŸŸå›¾è¡¨ï¼ˆä¿®å¤ç©ºç™½å›¾è¡¨é—®é¢˜ï¼‰==========
    function updateTimeDomainChart(waveform, channel) {
        // 1. Force Container Height (Fix Invisible Chart)
        const tContainer = document.getElementById('time-domain-chart');
        
        if (!tContainer) {
            console.error('[updateTimeDomainChart] å›¾è¡¨å®¹å™¨ä¸å­˜åœ¨');
            return;
        }
        if (tContainer.clientHeight < 200) {
            tContainer.style.height = '400px';
        }

        // 2. Data Safety (Fix Empty Array Crash)
        if (!waveform || !Array.isArray(waveform) || waveform.length === 0) {
            console.warn("[updateTimeDomainChart] æ³¢å½¢æ•°æ®ä¸ºç©ºï¼Œä½¿ç”¨é›¶çº¿");
            waveform = new Array(1024).fill(0);
        }

        // 3. Initialize Time Chart
        if (!timeDomainChart) {
            timeDomainChart = echarts.init(tContainer);
        }
        
        // ç”Ÿæˆ X è½´ï¼ˆå•ä½ï¼šmsï¼‰
        // å…³é”®ä¿®å¤ï¼šå°†æ—¶åŸŸå›¾ä» category è½´æ”¹ä¸º value è½´ï¼Œå¹¶ä½¿ç”¨ [t, y] æ•°æ®å¯¹ï¼Œ
        // è¿™æ · dataZoom çš„ startValue/endValue æ‰èƒ½æŒ‰â€œçœŸå®æ•°å€¼â€å·¥ä½œï¼Œç¼©å°æ‰èƒ½å›åˆ°å…¨èŒƒå›´ã€‚
        const timeAxis = Array.from({length: waveform.length}, (_, i) =>
            i * (200 / waveform.length)
        );
        const timeSeriesData = waveform.map((v, i) => [timeAxis[i], v]);

        // æŠŠâ€œå…¨é‡XèŒƒå›´â€æ˜¾å¼å†™å…¥å›¾è¡¨å®ä¾‹ï¼Œä¾›ç¼©æ”¾å·¥å…·ä½¿ç”¨ï¼ˆä¿è¯æ»šè½®ç¼©å°ä¸€å®šèƒ½å›åˆ°å…¨èŒƒå›´ï¼‰
        // æ³¨æ„ï¼šè¿™é‡Œ max ç”¨æœ€åä¸€ä¸ªé‡‡æ ·ç‚¹çš„æ—¶é—´ï¼ˆä¾‹å¦‚çº¦ 199.8msï¼‰ï¼Œä¸å›¾ä¸Šæ˜¾ç¤ºçš„æœ€å¤§å€¼ä¸€è‡´ã€‚
        if (timeDomainChart) {
            timeDomainChart.__edgewindFullExtentX = { min: 0, max: timeAxis[timeAxis.length - 1] };
        }

        // 4. Determine color (è·Ÿéšé€‰ä¸­çš„é€‰é¡¹å¡)
        const config = NODE_CONFIGS[currentNodeId];
        const isFault = config && (config.status === 'fault' || config.status === 'faulty');
        // æ ¹æ®å½“å‰é€‰ä¸­çš„æ•°æ®æºè·å–é¢œè‰²ï¼Œæ•…éšœæ—¶ç¨å¾®åŠ æ·±é¢œè‰²ä»¥ä¿æŒè§†è§‰æç¤º
        let lineColor = getSourceColor(currentSource);
        // å¦‚æœå¤„äºæ•…éšœçŠ¶æ€ï¼Œå¯ä»¥ç¨å¾®è°ƒæ•´é¢œè‰²ä»¥ä¿æŒè­¦å‘Šæ•ˆæœï¼ˆå¯é€‰ï¼‰
        // ç›®å‰ç›´æ¥ä½¿ç”¨æºé¢œè‰²ï¼Œä¿æŒä¸€è‡´æ€§

        // 5. Update Time Chart
        // å…³é”®ä¿®å¤ï¼šä¸è¦åœ¨é«˜é¢‘æ›´æ–°æ—¶é‡å¤å†™ dataZoomï¼Œå¦åˆ™ä¼šæŠŠç”¨æˆ·åˆšåˆšç¼©æ”¾çš„ X/Y è½´èŒƒå›´è¦†ç›–å›é»˜è®¤å€¼ï¼Œè¡¨ç°ä¸ºâ€œåªç¼©æ”¾X/æˆ–ç¼©æ”¾ä¸ç”Ÿæ•ˆâ€ã€‚
        const isFirstInit = !timeDomainChart._configInitialized;

        if (isFirstInit) {
            timeDomainChart.setOption({
                title: { 
                    text: `æ—¶åŸŸæ³¢å½¢ (${channel.label})`, 
                    left: 'center', 
                    top: 5 
                },
                tooltip: { 
                    trigger: 'axis',
                    formatter: function(params) {
                        const point = params[0];
                        const t = Array.isArray(point.value) ? point.value[0] : point.name;
                        const y = Array.isArray(point.value) ? point.value[1] : point.value;
                        return `æ—¶é—´: ${Number(t).toFixed(1)} ms<br/>${channel.label}: ${Number(y).toFixed(2)} ${channel.unit}`;
                    }
                },
                tooltip: { 
                    trigger: 'axis',
                    formatter: function(params) {
                        const point = params[0];
                        const t = Array.isArray(point.value) ? point.value[0] : point.name;
                        const y = Array.isArray(point.value) ? point.value[1] : point.value;
                        return `æ—¶é—´: ${Number(t).toFixed(1)} ms<br/>${channel.label}: ${Number(y).toFixed(2)} ${channel.unit}`;
                    }
                },
                grid: { 
                    left: 50, 
                    right: 30, 
                    top: 40, 
                    bottom: 40, 
                    containLabel: true 
                },
                // åªåœ¨é¦–æ¬¡åˆå§‹åŒ–æ—¶é…ç½® dataZoom
                dataZoom: [
                    { 
                        type: 'inside', 
                        xAxisIndex: [0],
                        // å…³é”®ä¿®å¤ï¼šä¸è¦è¿‡æ»¤æ•°æ®æœ¬ä½“ï¼Œå¦åˆ™ç¼©å°(zoom out)æ—¶â€œå…¨é‡èŒƒå›´â€ä¼šè¢«è¯¯åˆ¤ä¸ºå½“å‰çª—å£èŒƒå›´ï¼Œå¯¼è‡´å›ä¸å»å…¨èŒƒå›´
                        filterMode: 'none',
                        zoomOnMouseWheel: false,
                        moveOnMouseMove: false
                    },
                    { 
                        type: 'inside', 
                        yAxisIndex: [0], 
                        // åŒç†ï¼šY è½´ä¹Ÿä¸åšè¿‡æ»¤ï¼Œä»…æ”¹å˜è§†çª—
                        filterMode: 'none',
                        zoomOnMouseWheel: false,
                        moveOnMouseMove: false
                    }
                ],
                xAxis: { 
                    type: 'value',
                    name: 'æ—¶é—´ (ms)',
                    nameLocation: 'end',
                    axisLabel: { formatter: '{value}' }
                },
                yAxis: { 
                    type: 'value',
                    name: `${channel.label} (${channel.unit})`,
                    // æ—¶åŸŸå›¾å¿…é¡»èƒ½çœ‹åˆ° 0ï¼ˆè§„åˆ™è¦æ±‚ï¼šç¦æ­¢ scale:trueï¼‰
                    scale: false,
                    min: (val) => Math.min(0, val.min),
                    splitLine: { show: true } 
                },
                series: [{
                    data: timeSeriesData,
                    type: 'line',
                    showSymbol: false,
                    lineStyle: { 
                        width: 1.5, 
                        color: lineColor 
                    },
                    animation: false
                }]
            }, { notMerge: false, lazyUpdate: false });
            timeDomainChart._configInitialized = true;
        } else {
            // é«˜é¢‘æ›´æ–°åªæ›´æ–°æ•°æ®/æ ‡é¢˜/è½´åï¼Œä¸åŠ¨ dataZoom
            timeDomainChart.setOption({
                title: { 
                    text: `æ—¶åŸŸæ³¢å½¢ (${channel.label})`, 
                    left: 'center', 
                    top: 5 
                },
                xAxis: { name: 'æ—¶é—´ (ms)' },
                yAxis: { name: `${channel.label} (${channel.unit})` },
                series: [{
                    data: timeSeriesData,
                    lineStyle: { width: 1.5, color: lineColor }
                }]
            }, { notMerge: false, lazyUpdate: false });
        }
        // ^ IMPORTANT: Removed {notMerge: true} so zoom state is preserved!

        // 6. Ensure proper sizing (ç¼©æ”¾äº¤äº’åªéœ€è¦åˆå§‹åŒ–ä¸€æ¬¡ï¼›ä¸è¦åœ¨æ¯æ¬¡æ›´æ–°æ—¶é‡å¤ç»‘å®šäº‹ä»¶)
        setTimeout(() => {
            if (timeDomainChart) {
                timeDomainChart.resize();
                console.log(`[updateTimeDomainChart] âœ… å›¾è¡¨å·²æ›´æ–°: ${waveform.length}ä¸ªæ•°æ®ç‚¹ (ç¼©æ”¾çŠ¶æ€å·²ä¿æŒ)`);
            }
        }, 50);
    }

    // ========== æ›´æ–°é¢‘åŸŸå›¾è¡¨ï¼ˆä½¿ç”¨ä»åç«¯æ¥æ”¶çš„FFTæ•°æ®ï¼‰==========
    function updateFrequencyDomainChart(fft_spectrum_param, channel) {
        if (!frequencyDomainChart) return;
        
        // ä½¿ç”¨ requestAnimationFrame ä¼˜åŒ–æ¸²æŸ“æ€§èƒ½
        requestAnimationFrame(() => {
            // ä¼˜å…ˆä½¿ç”¨ä¼ å…¥çš„å‚æ•°ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä»ç¼“å­˜è·å–
            const channelData = nodeData[currentNodeId]?.[channel.id];
            const fft_spectrum = fft_spectrum_param && fft_spectrum_param.length > 0 
                ? fft_spectrum_param 
                : (channelData?.fft_spectrum || []);
            
            try {
                // å¦‚æœFFTæ•°æ®ä¸ºç©ºï¼Œæ˜¾ç¤ºåŠ è½½çŠ¶æ€è€Œä¸æ˜¯æ¸…ç©ºå›¾è¡¨
                if (!fft_spectrum || fft_spectrum.length === 0) {
                    // æ˜¾ç¤ºåŠ è½½åŠ¨ç”»
                    frequencyDomainChart.showLoading('default', {
                        text: 'ç­‰å¾…æ•°æ®...',
                        color: '#8e44ad',
                        textColor: '#666',
                        maskColor: 'rgba(255, 255, 255, 0.8)',
                        zlevel: 0
                    });
                    // æ ‡è®°é…ç½®å·²é‡ç½®ï¼Œä¸‹æ¬¡æœ‰æ•°æ®æ—¶éœ€è¦é‡æ–°åˆå§‹åŒ–
                    frequencyDomainChart._configInitialized = false;
                    return;
                }
                
                // å¦‚æœæœ‰æ•°æ®ï¼Œéšè—åŠ è½½åŠ¨ç”»
                frequencyDomainChart.hideLoading();
                
                // å¦‚æœæœ‰æ•°æ®ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦é‡æ–°åˆå§‹åŒ–é…ç½®
                const needsReinit = !frequencyDomainChart._configInitialized;
                
                // å¦‚æœéœ€è¦é‡æ–°åˆå§‹åŒ–ï¼Œå…ˆæ¸…ç©ºå›¾è¡¨
                if (needsReinit) {
                    frequencyDomainChart.clear();
                }
        
        // ç‰©ç†å¸¸æ•°ï¼ˆä¸åç«¯ä¸€è‡´ï¼‰
        const FREQ_RES = 5.0;  // é¢‘ç‡åˆ†è¾¨ç‡ï¼š5 Hz/bin
        const MAX_DISPLAY_BINS = 110;  // æ˜¾ç¤ºåˆ°550Hzï¼ˆ110 * 5Hz = 550Hzï¼‰
        
        // å¦‚æœåç«¯æä¾›äº†FFTæ•°æ®ï¼Œç›´æ¥ä½¿ç”¨
        if (fft_spectrum.length > 0) {
        const frequencies = [];
            const fftData = [];
            
            // åç«¯æä¾›115ä¸ªbinï¼ˆ0-575Hzï¼‰ï¼Œæ¯ä¸ªbinå¯¹åº”5Hz
            // Bin 0 = 0Hz (DC)
            // Bin 10 = 50Hz (E01æ•…éšœ) â† å…³é”®ï¼
            // Bin 30 = 150Hz (è°æ³¢)
            // æ˜¾ç¤ºå‰110ä¸ªbinï¼ˆ0-550Hzï¼‰
            const displayLength = Math.min(fft_spectrum.length, MAX_DISPLAY_BINS);
            for (let i = 0; i < displayLength; i++) {
                const freq = i * FREQ_RES;  // ç²¾ç¡®çš„5Hzåˆ†è¾¨ç‡
                frequencies.push(freq);
                fftData.push(fft_spectrum[i]);  // ç›´æ¥ä½¿ç”¨åç«¯DFTæ•°æ®
            }
            
            // æ¸²æŸ“å›¾è¡¨
            renderFFTChart(frequencies, fftData, channel);
        } else {
            // å¦‚æœæ²¡æœ‰FFTæ•°æ®ï¼Œæ˜¾ç¤ºç©ºå›¾è¡¨
            const frequencies = [];
            const fftData = [];
            for (let i = 0; i < MAX_DISPLAY_BINS; i++) {
                frequencies.push(i * FREQ_RES);
                fftData.push(0);  // æ˜¾ç¤ºä¸ºé›¶
            }
            renderFFTChart(frequencies, fftData, channel);
        }
            } catch (error) {
                console.error('[updateFrequencyDomainChart] æ›´æ–°é¢‘åŸŸå›¾è¡¨æ—¶å‡ºé”™:', error);
                // é”™è¯¯ä¸å½±å“åç»­æ›´æ–°
            }
        });  // é—­åˆ requestAnimationFrame
    }
    
    // ========== æ¸²æŸ“FFTå›¾è¡¨ï¼ˆè¾…åŠ©å‡½æ•°ï¼‰- ä¸“ä¸šæŠ˜çº¿å›¾ ==========
    function renderFFTChart(frequencies, fftData, channel) {
        if (!frequencyDomainChart) {
            console.warn('[renderFFTChart] å›¾è¡¨å®ä¾‹ä¸å­˜åœ¨');
            return;
        }
        
        try {
            // æ£€æŸ¥å›¾è¡¨æ˜¯å¦å¤„äºæŒ‚èµ·çŠ¶æ€ï¼ˆWebGL/Canvasé”™è¯¯ï¼‰
            if (frequencyDomainChart._disposed || !frequencyDomainChart.getDom()) {
                console.warn('[renderFFTChart] å›¾è¡¨å®ä¾‹å·²é”€æ¯æˆ–DOMä¸å­˜åœ¨ï¼Œé‡æ–°åˆå§‹åŒ–');
                // é”€æ¯æ—§å®ä¾‹
                if (frequencyDomainChart) {
                    try {
                        frequencyDomainChart.dispose();
                    } catch (e) {
                        console.warn('[renderFFTChart] é”€æ¯æ—§å®ä¾‹æ—¶å‡ºé”™:', e);
                    }
                }
                // é‡æ–°åˆå§‹åŒ–å›¾è¡¨
                const chartDom = document.getElementById('frequency-domain-chart');
                if (chartDom) {
                    frequencyDomainChart = echarts.init(chartDom);
                    frequencyDomainChart._configInitialized = false;
                } else {
                    console.error('[renderFFTChart] æ‰¾ä¸åˆ°å›¾è¡¨DOMå…ƒç´ ');
            return;
                }
            }
            
            // é¢‘åŸŸå›¾æ”¹ä¸º value è½´ + [é¢‘ç‡, å¹…å€¼] æ•°æ®å¯¹ï¼ˆä¿è¯ç¼©æ”¾/ç¼©å°/æ‹–æ‹½é€»è¾‘ä¸æ—¶åŸŸä¸€è‡´ï¼‰
            const fftSeriesData = frequencies.map((f, i) => [f, fftData[i]]);
            
            // è®¡ç®—Yè½´æœ€å¤§å€¼ï¼ˆåŠ¨æ€è°ƒæ•´ï¼Œç•™10%ä½™é‡ï¼‰
            // ç¡®ä¿æ­£ç¡®å¤„ç†ç©ºæ•°ç»„æˆ–æ— æ•ˆæ•°æ®
            const validData = fftData.filter(val => !isNaN(val) && isFinite(val));
            const maxVal = validData.length > 0 ? Math.max(...validData) : 0;
            const yAxisMax = maxVal > 0 ? maxVal * 1.1 : 50;

            // æ˜¾å¼æä¾›â€œå…¨é‡èŒƒå›´â€ï¼Œä¿è¯æ»šè½®ç¼©å°ä¸€å®šèƒ½å›åˆ°å…¨èŒƒå›´ï¼ˆä¸æ—¶åŸŸä¸€è‡´ï¼‰
            if (frequencyDomainChart) {
                const xMin = frequencies.length ? frequencies[0] : 0;
                const xMax = frequencies.length ? frequencies[frequencies.length - 1] : 0;
                frequencyDomainChart.__edgewindFullExtentX = { min: xMin, max: xMax };
                frequencyDomainChart.__edgewindFullExtentY = { min: 0, max: yAxisMax };
            }
        
        // æ ¹æ®å½“å‰é€‰ä¸­çš„æ•°æ®æºç¡®å®šé¢œè‰²ï¼ˆè·Ÿéšé€‰é¡¹å¡ï¼‰
        const config = NODE_CONFIGS[currentNodeId];
        const isFault = config && (config.status === 'fault' || config.status === 'faulty');
        // ä½¿ç”¨å½“å‰é€‰ä¸­æºçš„å¯¹åº”é¢œè‰²
        const sourceColor = getSourceColor(currentSource);
        const lineColor = sourceColor;
            
            // æ£€æŸ¥æ˜¯å¦éœ€è¦é‡æ–°åˆå§‹åŒ–
            const needsReinit = !frequencyDomainChart._configInitialized;
            
            // æ›´æ–°æ•°æ®å’Œé¢œè‰²ï¼ˆç¡®ä¿é¢œè‰²è·Ÿéšé€‰é¡¹å¡å˜åŒ–ï¼‰
            frequencyDomainChart.setOption({
                series: [{
                    data: fftSeriesData,
                    lineStyle: {
                        color: lineColor
                    },
                    areaStyle: {
                        color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                            { offset: 0, color: hexToRgba(sourceColor, 0.5) },
                            { offset: 1, color: hexToRgba(sourceColor, 0.1) }
                        ])
                    }
                }]
            }, {
                notMerge: false,  // å§‹ç»ˆåˆå¹¶ï¼Œä¿ç•™å…¶ä»–é…ç½®
                lazyUpdate: !needsReinit  // åªåœ¨éé‡æ–°åˆå§‹åŒ–æ—¶ä½¿ç”¨å»¶è¿Ÿæ›´æ–°
            });
            
            // åªåœ¨é¦–æ¬¡æˆ–é…ç½®å˜åŒ–æ—¶æ›´æ–°å®Œæ•´é…ç½®
            if (needsReinit) {
        frequencyDomainChart.setOption({
            tooltip: {
                trigger: 'axis',
                formatter: function(params) {
                    const point = params[0];
                    const freq = Array.isArray(point.value) ? point.value[0] : frequencies[point.dataIndex];
                    const amp = Array.isArray(point.value) ? point.value[1] : point.value;
                        const unit = channel.unit || '';
                        return `é¢‘ç‡: ${freq.toFixed(1)} Hz<br/>å¹…åº¦: ${amp.toFixed(3)} ${unit}`;
                }
            },
            grid: {
                top: 40,
                left: 50,
                right: 20,
                bottom: 40,
                containLabel: true
            },
            xAxis: {
                type: 'value',
                min: 0,
                max: frequencies.length ? frequencies[frequencies.length - 1] : 550,
                name: 'é¢‘ç‡ (Hz)',
                nameLocation: 'middle',
                nameGap: 30,
                nameTextStyle: { color: '#64748b' },
                axisLabel: {
                    formatter: function(value) {
                        const freq = Number(value);
                        if (!Number.isFinite(freq)) return '';
                        // ç‰¹åˆ«æ ‡æ³¨50Hzï¼ˆE01æ•…éšœé¢‘ç‡ï¼‰
                        if (Math.abs(freq - 50) < 0.1) return '50Hz';
                        if (freq % 50 === 0) return freq + 'Hz';
                        return '';
                    }
                },
                splitLine: { show: false }
            },
            yAxis: {
                type: 'value',
                name: 'å¹…åº¦ (V æˆ– A)',
                nameLocation: 'middle',
                nameGap: 50,
                nameTextStyle: { color: '#64748b' },
                min: 0,
                max: yAxisMax,
                splitLine: {
                    show: true,
                    lineStyle: { type: 'dashed' }
                }
            },
            // ä¸æ—¶åŸŸä¸€è‡´ï¼šX/Y è½´ç‹¬ç«‹ç¼©æ”¾ + Grab æ‹–æ‹½ï¼ˆç”± setupChartZoom ç»Ÿä¸€æ§åˆ¶ï¼‰
            dataZoom: [
                {
                    type: 'inside',
                    xAxisIndex: [0],
                    filterMode: 'none',
                    zoomOnMouseWheel: false,
                    moveOnMouseMove: false,
                    moveOnMouseWheel: false
                },
                {
                    type: 'inside',
                    yAxisIndex: [0],
                    filterMode: 'none',
                    zoomOnMouseWheel: false,
                    moveOnMouseMove: false,
                    moveOnMouseWheel: false
                }
            ],
            series: [{
                name: 'é¢‘è°±å¹…å€¼',
                type: 'line',  // æŠ˜çº¿å›¾
                smooth: true,  // å¹³æ»‘æ›²çº¿
                symbol: 'none',  // éšè—æ•°æ®ç‚¹ï¼Œä¿æŒå¹²å‡€çš„é¢‘è°±å¤–è§‚
                lineStyle: {
                    width: 2,
                    color: lineColor
                },
                areaStyle: {
                    color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                        { offset: 0, color: hexToRgba(sourceColor, 0.5) },
                        { offset: 1, color: hexToRgba(sourceColor, 0.1) }
                    ])
                },
                data: fftSeriesData,
                emphasis: {
                    focus: 'series',
                    lineStyle: {
                        width: 3
                    }
                }
            }]
            }, {
                notMerge: false,
                lazyUpdate: false
            });
            frequencyDomainChart._configInitialized = true;
            }
        } catch (error) {
            console.error('[renderFFTChart] æ¸²æŸ“FFTå›¾è¡¨æ—¶å‡ºé”™:', error);
            // å¦‚æœæ¸²æŸ“å¤±è´¥ï¼Œå°è¯•é‡ç½®å›¾è¡¨
            if (frequencyDomainChart) {
                try {
                    frequencyDomainChart.dispose();
                    const chartDom = document.getElementById('frequency-domain-chart');
                    if (chartDom) {
                        frequencyDomainChart = echarts.init(chartDom);
                        frequencyDomainChart._configInitialized = false;
                        console.log('[renderFFTChart] å›¾è¡¨å·²é‡ç½®ï¼Œç­‰å¾…ä¸‹æ¬¡æ•°æ®æ›´æ–°');
                    }
                } catch (resetError) {
                    console.error('[renderFFTChart] é‡ç½®å›¾è¡¨æ—¶å‡ºé”™:', resetError);
                }
            }
        }
    }

    // ========== è®¾ç½®VOFA+é£æ ¼ç¤ºæ³¢å™¨äº¤äº’ï¼ˆæ™ºèƒ½è½´ç‹¬ç«‹ç¼©æ”¾ï¼‰==========
    function setupOscilloscopeInteractions() {
        if (!timeDomainChart) return;
        
        const chartDom = document.getElementById('time-domain-chart');
        if (!chartDom) return;
        
        let isOverXAxis = false;
        let isOverYAxis = false;
        let mouseX = 0;
        let mouseY = 0;
        
        // æ£€æµ‹é¼ æ ‡ä½ç½®ï¼ˆæ˜¯å¦åœ¨Xè½´æˆ–Yè½´åŒºåŸŸï¼‰- ç²¾ç¡®æ£€æµ‹è½´åŒºåŸŸ
        chartDom.addEventListener('mousemove', function(e) {
            const rect = chartDom.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
            const width = rect.width;
            const height = rect.height;
            
            // Xè½´åŒºåŸŸï¼šåº•éƒ¨20%çš„åŒºåŸŸï¼ˆåŒ…æ‹¬Xè½´æ ‡ç­¾ã€åˆ»åº¦å’Œæ»‘å—ï¼‰
            // æ£€æµ‹é¼ æ ‡æ˜¯å¦åœ¨Xè½´åŒºåŸŸï¼ˆåº•éƒ¨20%ï¼‰
            isOverXAxis = (mouseY > height * 0.80);
            
            // Yè½´åŒºåŸŸï¼šå·¦ä¾§18%çš„åŒºåŸŸï¼ˆåŒ…æ‹¬Yè½´æ ‡ç­¾å’Œåˆ»åº¦ï¼‰
            // æ£€æµ‹é¼ æ ‡æ˜¯å¦åœ¨Yè½´åŒºåŸŸï¼ˆå·¦ä¾§18%ï¼‰
            isOverYAxis = (mouseX < width * 0.18);
            
            // æ³¨æ„ï¼šå¦‚æœé¼ æ ‡åŒæ—¶åœ¨Xè½´å’ŒYè½´çš„äº¤é›†åŒºåŸŸï¼ˆå·¦ä¸‹è§’ï¼‰ï¼Œä¼˜å…ˆå¤„ç†Yè½´
            // å› ä¸ºYè½´çš„æ£€æµ‹ä¼˜å…ˆçº§æ›´é«˜ï¼ˆæ›´å¸¸ç”¨ï¼‰
        });
        
        // é¼ æ ‡ç¦»å¼€å›¾è¡¨åŒºåŸŸæ—¶é‡ç½®
        chartDom.addEventListener('mouseleave', function() {
            isOverXAxis = false;
            isOverYAxis = false;
        });
        
        // åŒå‡»é‡ç½®åŠŸèƒ½ï¼šåŒå‡»Yè½´é‡ç½®Yè½´ï¼ŒåŒå‡»Xè½´é‡ç½®Xè½´ï¼ŒåŒå‡»å›¾è¡¨åŒºåŸŸé‡ç½®ä¸¤ä¸ªè½´
        let lastClickTime = 0;
        chartDom.addEventListener('dblclick', function(e) {
            if (!timeDomainChart) return;
            
            const rect = chartDom.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            const width = rect.width;
            const height = rect.height;
            
            const isClickOnXAxis = (clickY > height * 0.80);
            const isClickOnYAxis = (clickX < width * 0.18);
            
            const currentOption = timeDomainChart.getOption();
            const currentDataZoom = currentOption.dataZoom || [];
            
            // åˆ›å»ºæ–°çš„dataZoomé…ç½®
            const newDataZoom = currentDataZoom.map(dz => {
                // åŒå‡»Yè½´ï¼šé‡ç½®Yè½´ç¼©æ”¾ï¼ˆæ˜¾ç¤ºå®Œæ•´èŒƒå›´ï¼‰
                if (isClickOnYAxis && !isClickOnXAxis && dz.type === 'inside' && dz.yAxisIndex && dz.yAxisIndex[0] === 0) {
                    return {
                        ...dz,
                        start: 0,
                        end: 100
                    };
                }
                // åŒå‡»Xè½´ï¼šé‡ç½®Xè½´ç¼©æ”¾ï¼ˆæ˜¾ç¤ºå®Œæ•´èŒƒå›´ï¼‰
                else if (isClickOnXAxis && !isClickOnYAxis && dz.type === 'inside' && dz.xAxisIndex && dz.xAxisIndex[0] === 0) {
                    return {
                        ...dz,
                        start: 0,
                        end: 100
                    };
                }
                // åŒå‡»å›¾è¡¨åŒºåŸŸï¼šé‡ç½®ä¸¤ä¸ªè½´ï¼ˆæ˜¾ç¤ºå®Œæ•´èŒƒå›´ï¼‰
                else if (!isClickOnXAxis && !isClickOnYAxis) {
                    if (dz.type === 'inside' && dz.xAxisIndex && dz.xAxisIndex[0] === 0) {
                        return {
                            ...dz,
                            start: 0,
                            end: 100
                        };
                    }
                    if (dz.type === 'inside' && dz.yAxisIndex && dz.yAxisIndex[0] === 0) {
                        return {
                            ...dz,
                            start: 0,
                            end: 100
                        };
                    }
                }
                return dz;
            });
            
            // åº”ç”¨é‡ç½®
            timeDomainChart.setOption({
                dataZoom: newDataZoom
            }, {
                notMerge: false,
                lazyUpdate: false
            });
        });
        
        // è‡ªå®šä¹‰æ»šè½®äº‹ä»¶å¤„ç†ï¼ˆVOFA+é£æ ¼ï¼šæ™ºèƒ½è½´ç‹¬ç«‹ç¼©æ”¾ï¼‰
        chartDom.addEventListener('wheel', function(e) {
            if (!timeDomainChart) return;
            
            // è·å–é¼ æ ‡ä½ç½®ï¼ˆç”¨äºåˆ¤æ–­åœ¨å“ªä¸ªåŒºåŸŸï¼‰- åœ¨é˜»æ­¢é»˜è®¤è¡Œä¸ºä¹‹å‰è·å–
            const rect = chartDom.getBoundingClientRect();
            const wheelX = e.clientX - rect.left;
            const wheelY = e.clientY - rect.top;
            const width = rect.width;
            const height = rect.height;
            
            // å®æ—¶æ£€æµ‹é¼ æ ‡ä½ç½®ï¼ˆæ»šè½®äº‹ä»¶æ—¶ï¼‰
            const isWheelOnXAxis = (wheelY > height * 0.80);
            const isWheelOnYAxis = (wheelX < width * 0.18);
            
            // è°ƒè¯•ä¿¡æ¯ï¼ˆä¸´æ—¶å¯ç”¨ä»¥éªŒè¯æ£€æµ‹é€»è¾‘ï¼‰
            // console.log('Wheel position:', { wheelX, wheelY, width, height, isWheelOnXAxis, isWheelOnYAxis });
            
            // å®Œå…¨é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œé˜²æ­¢EChartsåŸç”Ÿç¼©æ”¾å¹²æ‰°
            e.preventDefault();
            e.stopPropagation();
            
            // è·å–ç¼©æ”¾æ–¹å‘ï¼ˆå‘ä¸Šæ»šåŠ¨æ”¾å¤§ï¼Œå‘ä¸‹æ»šåŠ¨ç¼©å°ï¼‰
            // deltaY < 0 è¡¨ç¤ºå‘ä¸Šæ»šåŠ¨ï¼ˆæ”¾å¤§ï¼‰ï¼ŒdeltaY > 0 è¡¨ç¤ºå‘ä¸‹æ»šåŠ¨ï¼ˆç¼©å°ï¼‰
            const zoomFactor = e.deltaY < 0 ? 1.10 : 0.90;
            
            // è·å–å½“å‰dataZoomçŠ¶æ€ï¼ˆç›´æ¥ä»EChartså†…éƒ¨çŠ¶æ€è·å–ï¼Œæ›´å‡†ç¡®ï¼‰
            const option = timeDomainChart.getOption();
            const dataZoom = option.dataZoom || [];
            
            // è·å–Xè½´å’ŒYè½´çš„å½“å‰ç¼©æ”¾èŒƒå›´
            let xDataZoom = dataZoom.find(dz => dz.type === 'inside' && dz.xAxisIndex && dz.xAxisIndex[0] === 0);
            let yDataZoom = dataZoom.find(dz => dz.type === 'inside' && dz.yAxisIndex && dz.yAxisIndex[0] === 0);
            
            // å¦‚æœdataZoomæœªåˆå§‹åŒ–ï¼Œä½¿ç”¨é»˜è®¤å€¼ï¼ˆå…¨èŒƒå›´æ˜¾ç¤ºï¼‰
            let xStart = (xDataZoom && xDataZoom.start !== undefined) ? xDataZoom.start : 0;
            let xEnd = (xDataZoom && xDataZoom.end !== undefined) ? xDataZoom.end : 100;
            let yStart = (yDataZoom && yDataZoom.start !== undefined) ? yDataZoom.start : 0;
            let yEnd = (yDataZoom && yDataZoom.end !== undefined) ? yDataZoom.end : 100;
            
            // è°ƒè¯•ä¿¡æ¯ï¼ˆå¯é€‰ï¼Œç”¨äºéªŒè¯é€»è¾‘ï¼‰
            // console.log('Mouse position:', { isOverXAxis, isOverYAxis, xStart, xEnd, yStart, yEnd });
            
            // è®¡ç®—æ–°çš„ç¼©æ”¾èŒƒå›´
            let newXStart = xStart;
            let newXEnd = xEnd;
            let newYStart = yStart;
            let newYEnd = yEnd;
            
            // ========== æ ¹æ®é¼ æ ‡ä½ç½®å†³å®šç¼©æ”¾è¡Œä¸º ==========
            // ä½¿ç”¨æ»šè½®äº‹ä»¶æ—¶çš„å®æ—¶ä½ç½®ï¼ˆæ›´å‡†ç¡®ï¼‰
            // æƒ…å†µ1ï¼šé¼ æ ‡åœ¨Xè½´ä¸Šï¼ˆä¸åœ¨Yè½´ä¸Šï¼‰â†’ åªç¼©æ”¾Xè½´ï¼ˆæ—¶åŸºè°ƒæ•´ï¼‰
            if (isWheelOnXAxis && !isWheelOnYAxis) {
                const xCenter = (xStart + xEnd) / 2;
                const xRange = (xEnd - xStart) / zoomFactor;
                const minRange = 1;
                const maxRange = 100;
                const clampedRange = Math.max(minRange, Math.min(maxRange, xRange));
                newXStart = Math.max(0, Math.min(100 - clampedRange, xCenter - clampedRange / 2));
                newXEnd = Math.min(100, Math.max(clampedRange, xCenter + clampedRange / 2));
                // Yè½´æ˜ç¡®ä¿æŒä¸å˜ï¼ˆä½¿ç”¨å½“å‰å€¼ï¼‰
                newYStart = yStart;
                newYEnd = yEnd;
                // console.log('Xè½´ç¼©æ”¾:', { xStart, xEnd, newXStart, newXEnd, yStart, yEnd, newYStart, newYEnd });
            }
            // æƒ…å†µ2ï¼šé¼ æ ‡åœ¨Yè½´ä¸Šï¼ˆä¸åœ¨Xè½´ä¸Šï¼‰â†’ åªç¼©æ”¾Yè½´ï¼ˆç”µå‹/ç”µæµå¢ç›Šè°ƒæ•´ï¼‰
            else if (isWheelOnYAxis && !isWheelOnXAxis) {
                const yCenter = (yStart + yEnd) / 2;
                const yRange = (yEnd - yStart) / zoomFactor;
                const minRange = 1;
                const maxRange = 100;
                const clampedRange = Math.max(minRange, Math.min(maxRange, yRange));
                newYStart = Math.max(0, Math.min(100 - clampedRange, yCenter - clampedRange / 2));
                newYEnd = Math.min(100, Math.max(clampedRange, yCenter + clampedRange / 2));
                // Xè½´æ˜ç¡®ä¿æŒä¸å˜ï¼ˆä½¿ç”¨å½“å‰å€¼ï¼‰
                newXStart = xStart;
                newXEnd = xEnd;
                // console.log('Yè½´ç¼©æ”¾:', { xStart, xEnd, newXStart, newXEnd, yStart, yEnd, newYStart, newYEnd });
            }
            // æƒ…å†µ3ï¼šé¼ æ ‡åœ¨æ³¢å½¢åŒºåŸŸï¼ˆæ—¢ä¸åœ¨Xè½´ä¹Ÿä¸åœ¨Yè½´ä¸Šï¼‰â†’ åŒæ—¶ç¼©æ”¾Xå’ŒYè½´ï¼ˆä¸­å¿ƒç¼©æ”¾ï¼‰
            else if (!isWheelOnXAxis && !isWheelOnYAxis) {
                // åŒæ—¶ç¼©æ”¾Xå’ŒYè½´
                const xCenter = (xStart + xEnd) / 2;
                const xRange = (xEnd - xStart) / zoomFactor;
                const minRange = 1;
                const maxRange = 100;
                const clampedXRange = Math.max(minRange, Math.min(maxRange, xRange));
                newXStart = Math.max(0, Math.min(100 - clampedXRange, xCenter - clampedXRange / 2));
                newXEnd = Math.min(100, Math.max(clampedXRange, xCenter + clampedXRange / 2));
                
                const yCenter = (yStart + yEnd) / 2;
                const yRange = (yEnd - yStart) / zoomFactor;
                const clampedYRange = Math.max(minRange, Math.min(maxRange, yRange));
                newYStart = Math.max(0, Math.min(100 - clampedYRange, yCenter - clampedYRange / 2));
                newYEnd = Math.min(100, Math.max(clampedYRange, yCenter + clampedYRange / 2));
            }
            // å…¶ä»–æƒ…å†µï¼ˆä¾‹å¦‚åœ¨äº¤å‰åŒºåŸŸï¼‰ï¼Œä¸è¿›è¡Œç¼©æ”¾
            else {
                return;  // ä¸æ‰§è¡Œä»»ä½•ç¼©æ”¾æ“ä½œ
            }
            
            // åº”ç”¨æ–°çš„ç¼©æ”¾èŒƒå›´ï¼ˆä½¿ç”¨setOptionç›´æ¥æ›´æ–°ï¼Œç¡®ä¿å®Œå…¨ç‹¬ç«‹æ§åˆ¶ï¼‰
            const currentOption = timeDomainChart.getOption();
            const currentDataZoom = currentOption.dataZoom || [];
            
            // åˆ›å»ºæ–°çš„dataZoomé…ç½®ï¼Œæ˜ç¡®ä¿æŒå¦ä¸€ä¸ªè½´ä¸å˜
            const newDataZoom = currentDataZoom.map(dz => {
                // Xè½´çš„dataZoom
                if (dz.type === 'inside' && dz.xAxisIndex && dz.xAxisIndex[0] === 0) {
                    // å¦‚æœXè½´éœ€è¦æ›´æ–°ï¼Œæ›´æ–°å®ƒï¼›å¦åˆ™ä¿æŒåŸå€¼
                    return {
                        ...dz,
                        start: newXStart,
                        end: newXEnd
                    };
                }
                // Yè½´çš„dataZoom
                else if (dz.type === 'inside' && dz.yAxisIndex && dz.yAxisIndex[0] === 0) {
                    // å¦‚æœYè½´éœ€è¦æ›´æ–°ï¼Œæ›´æ–°å®ƒï¼›å¦åˆ™ä¿æŒåŸå€¼
                    return {
                        ...dz,
                        start: newYStart,
                        end: newYEnd
                    };
                }
                // å…¶ä»–dataZoomï¼ˆå¦‚sliderï¼‰ä¿æŒä¸å˜
                return dz;
            });
            
            // ä½¿ç”¨setOptionæ›´æ–°ï¼Œç¡®ä¿åªæ›´æ–°dataZoomï¼Œå…¶ä»–é…ç½®ä¸å—å½±å“
            // æ£€æŸ¥æ˜¯å¦æœ‰ä»»ä½•å˜åŒ–
            const hasXChange = (newXStart !== xStart || newXEnd !== xEnd);
            const hasYChange = (newYStart !== yStart || newYEnd !== yEnd);
            
            if (hasXChange || hasYChange) {
                timeDomainChart.setOption({
                    dataZoom: newDataZoom
                }, {
                    notMerge: false,  // åˆå¹¶æ¨¡å¼
                    lazyUpdate: false,  // ç«‹å³æ›´æ–°
                    silent: false  // è§¦å‘äº‹ä»¶
                });
            }
        }, { passive: false });
    }

    // ========== é‡ç½®æ—¶åŸŸå›¾è¡¨ç¼©æ”¾ ==========
    function resetTimeDomainZoom() {
        if (!timeDomainChart) return;
        
        const currentOption = timeDomainChart.getOption();
        const currentDataZoom = currentOption.dataZoom || [];
        
        // é‡ç½®æ‰€æœ‰insideç±»å‹çš„dataZoomåˆ°å…¨èŒƒå›´ï¼ˆ0-100%ï¼‰
        const newDataZoom = currentDataZoom.map(dz => {
            if (dz.type === 'inside') {
                return {
                    ...dz,
                    start: 0,
                    end: 100
                };
            }
            return dz;
        });
        
        // åº”ç”¨é‡ç½®
        timeDomainChart.setOption({
            dataZoom: newDataZoom
        }, {
            notMerge: false,
            lazyUpdate: false
        });
    }

    // ========== é‡ç½®é¢‘åŸŸå›¾è¡¨ç¼©æ”¾ ==========
    function resetFrequencyDomainZoom() {
        if (!frequencyDomainChart) return;
        
        const currentOption = frequencyDomainChart.getOption();
        const currentDataZoom = currentOption.dataZoom || [];
        
        // é‡ç½®æ‰€æœ‰insideç±»å‹çš„dataZoomåˆ°å…¨èŒƒå›´ï¼ˆ0-100%ï¼‰
        const newDataZoom = currentDataZoom.map(dz => {
            if (dz.type === 'inside') {
                return {
                    ...dz,
                    start: 0,
                    end: 100,
                    startValue: null,
                    endValue: null
                };
            }
            return dz;
        });
        
        frequencyDomainChart.setOption({
            dataZoom: newDataZoom
        }, {
            notMerge: false,
            lazyUpdate: false
        });
    }

    // ========== åº”ç”¨æ•…éšœæ¨¡å¼è§†è§‰æ•ˆæœ ==========
    function applyFaultModeEffects(status) {
        const isFault = status === 'fault' || status === 'faulty';
        const timeChartContainer = document.getElementById('time-domain-chart-container');
        const freqChartContainer = document.getElementById('frequency-domain-chart-container');
        
        if (timeChartContainer) {
            if (isFault) {
                timeChartContainer.classList.add('chart-fault-overlay');
            } else {
                timeChartContainer.classList.remove('chart-fault-overlay');
            }
        }
        
        if (freqChartContainer) {
            if (isFault) {
                freqChartContainer.classList.add('chart-fault-overlay');
            } else {
                freqChartContainer.classList.remove('chart-fault-overlay');
            }
        }
    }

    // ========== å·¥å…·å‡½æ•° ==========
    function formatValue(value, unit) {
        if (unit === 'V' || unit === 'A' || unit === 'kW' || unit === 'kVar') {
            return value.toFixed(2);
        } else if (unit === 'mA') {
            return value.toFixed(3);
        } else if (unit === 'Â°C' || unit === '%' || unit === 'MÎ©') {
            return value.toFixed(1);
        } else if (unit === 'rpm' || unit === 'deg') {
            return Math.round(value);
        }
        return value.toFixed(2);
    }

    // ========== æ ¹æ®å½“å‰é€‰ä¸­çš„æ•°æ®æºè·å–å¯¹åº”çš„é¢œè‰² ==========
    function getSourceColor(source) {
        // æ ¹æ®é¡¹ç›®é¢œè‰²ç¼–ç æ ‡å‡†æ˜ å°„
        const colorMap = {
            'voltage': '#0d6efd',      // è“è‰² (ç›´æµæ¯çº¿+)
            'voltage_neg': '#dc3545',  // çº¢è‰² (ç›´æµæ¯çº¿-)
            'current': '#0dcaf0',      // é’è‰² (è´Ÿè½½ç”µæµ)
            'leakage': '#ffc107'       // é»„è‰² (æ¼ç”µæµ)
        };
        return colorMap[source] || '#0d6efd';  // é»˜è®¤è“è‰²
    }

    // ========== å°†åå…­è¿›åˆ¶é¢œè‰²è½¬æ¢ä¸ºRGBA ==========
    function hexToRgba(hex, alpha) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    // ========== CSSæ ·å¼ ==========
    const style = document.createElement('style');
    style.textContent = `
        @keyframes pulse-danger {
            0% { 
                box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7);
            }
            70% { 
                box-shadow: 0 0 0 15px rgba(220, 53, 69, 0); 
            }
            100% { 
                box-shadow: 0 0 0 0 rgba(220, 53, 69, 0); 
            }
        }
        
        .fault-pulse {
            animation: pulse-danger 2s infinite;
        }
        
        .chart-fault-overlay {
            border: 2px solid #dc3545 !important;
            background-color: rgba(220, 53, 69, 0.05) !important;
            border-radius: 4px;
            transition: all 0.3s ease;
        }
        
        .list-group-item {
            transition: all 0.2s ease;
        }
        
        .list-group-item:hover {
            background-color: #f8f9fa;
        }
        
        .cursor-pointer { 
            cursor: pointer; 
            transition: all 0.2s ease;
        }
        
        /* Card Interaction Styles */
        .card-select {
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            border: 2px solid transparent; /* Placeholder for border */
        }
        
        .card-select:hover { 
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.1) !important;
        }
        
        /* Active State */
        .card-active {
            background-color: #f8f9fa !important;
            border-color: #0d6efd !important; /* Blue border for active */
            box-shadow: 0 0 15px rgba(13, 110, 253, 0.2) !important;
        }
        
        /* The "Selected" Badge Text - Hidden by default */
        .select-badge {
            opacity: 0;
            transform: translateY(5px);
            transition: all 0.2s;
            font-size: 0.85rem;
            font-weight: bold;
        }
        
        /* Show when parent has .card-active */
        .card-active .select-badge {
            opacity: 1;
            transform: translateY(0);
        }
        
        .channel-card {
            transition: all 0.2s ease;
        }
        
        .channel-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        
        .channel-card.border-primary {
            background-color: #e7f3ff !important;
        }
        
        /* æ ‡ç­¾é¡µæ ·å¼ */
        .card-header-tabs .nav-link {
            color: rgba(255, 255, 255, 0.7);
            border: none;
            border-bottom: 2px solid transparent;
            padding: 0.75rem 1.5rem;
            transition: all 0.2s ease;
        }
        
        .card-header-tabs .nav-link:hover {
            color: rgba(255, 255, 255, 0.9);
            border-bottom-color: rgba(255, 255, 255, 0.3);
        }
        
        .card-header-tabs .nav-link.active {
            color: #fff;
            background-color: transparent;
            border-bottom-color: #fff;
            font-weight: 600;
        }
        
        .tab-pane {
            min-height: 450px;
        }
        
        #time-domain-chart,
        #frequency-domain-chart {
            min-height: 600px;
        }
    `;
    document.head.appendChild(style);
    
    // ========== Toast é€šçŸ¥åŠŸèƒ½ ==========
    // å°† showToast æš´éœ²ä¸ºå…¨å±€å‡½æ•°ï¼Œä¾› publishSystemEvent è°ƒç”¨
    window.showToast = function(message, type = 'info') {
        const container = document.getElementById('toast-container');
        if (!container) return;
        
        // ç±»å‹æ˜ å°„
        const typeConfig = {
            'success': { icon: 'âœ…', color: 'success' },
            'warning': { icon: 'âš ï¸', color: 'warning' },
            'error': { icon: 'âŒ', color: 'error' },
            'info': { icon: 'â„¹ï¸', color: 'info' }
        };
        
        const config = typeConfig[type] || typeConfig['info'];
        
        // åˆ›å»º Toast å…ƒç´ 
        const toast = document.createElement('div');
        toast.className = `custom-toast ${config.color}`;
        toast.innerHTML = `
            <span class="custom-toast-icon">${config.icon}</span>
            <div class="custom-toast-content">
                <div class="custom-toast-message">${escapeHtml(message)}</div>
            </div>
            <span class="custom-toast-close" onclick="this.parentElement.remove()">Ã—</span>
        `;
        
        // æ·»åŠ åˆ°å®¹å™¨
        container.appendChild(toast);
        
        // è‡ªåŠ¨ç§»é™¤ï¼ˆ5ç§’åï¼‰
        setTimeout(() => {
            toast.classList.add('fade-out');
            setTimeout(() => {
                if (toast.parentElement) {
                    toast.remove();
                }
            }, 300);
        }, 5000);
    };
    
    // ä¿æŒå‘åå…¼å®¹
    const showToast = window.showToast;
</script>
{% endblock %}